<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <title>Training - Talk2Sign</title>
    <!-- Basic Three.js -->
    <script src="https://unpkg.com/three@0.133.0/build/three.js"></script>
    <!-- GLTF Loader for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Orbit Controls for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/controls/OrbitControls.js"></script>
    <!-- VRM Loader for Three.js -->
    <script src="https://unpkg.com/@pixiv/three-vrm@0.6.7/lib/three-vrm.js"></script>
    <!-- Mediapipe or Tensorflow.js -->
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/holistic.js"
      crossorigin="anonymous"
    ></script>
    <!-- Mediapipe Drawing Tools -->
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <!-- Mediapipe Camera Tools -->
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <!-- Kalidokit UMD version -->
    <script src="./training/kalidokit.umd.js"></script>
    <style>
      /* Inline CSS from style.css for GitHub Pages compatibility */
      @font-face {
        font-family: "Jelly";
        font-display: block;
        src: url("https://yeemachine.github.io/kalidoface-live2d-models/Font/kalidoface-jelly.ttf") format("truetype");
      }
      h1 {
        font-family: "Jelly";
        font-size: 32px;
        color: white;
        position: absolute;
        top: -12px;
        left: 16px;
        font-weight: normal;
        -webkit-font-feature-settings: "liga";
        font-feature-settings: "liga";
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      h1:hover {
        color: #13a3f3;
      }
      a,
      a:visited,
      a:link {
        text-decoration: none;
        color: #222;
        display: inline-block;
      }
      a:hover,
      a:visited:hover,
      a:link:hover {
        color: #13a3f3;
        cursor: pointer;
      }
      .preview {
        display: flex;
        flex-direction: column;
        position: absolute;
        bottom: 16px;
        right: 16px;
        overflow: hidden;
        border-radius: 8px;
        background: #222;
      }
      video {
        max-width: 400px;
        height: auto;
        transform: scale(-1, 1);
      }
      .preview canvas {
        transform: scale(-1, 1);
      }
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
      .guides {
        position: absolute;
        bottom: 0;
        left: 0;
        height: auto;
        width: 100%;
        z-index: 1;
      }
      nav {
        position: absolute;
        top: 12px;
        right: 16px;
        display: flex;
      }
      nav img {
        width: 36px;
        height: auto;
        margin-left: 22px;
      }
      section {
        position: absolute;
        bottom: 0;
        right: 0;
        padding: 32px 0 16px 0;
        display: flex;
        justify-content: center;
        width: 100%;
        background: rgb(0, 0, 0);
        background: linear-gradient(0deg, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 100%);
        color: white;
        z-index: 2;
      }
      p {
        color: white;
        padding: 8px 16px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
        margin: 0;
      }
      .preview a {
        border-radius: 24px;
        margin: 0 4px;
      }
      .preview a:hover {
        background: #ffffff20;
      }
      a.current {
        background: #13a3f3;
        pointer-events: none;
      }
      .linkOut {
        position: absolute;
        bottom: 16px;
        left: 16px;
        display: inline;
        color: black;
        padding: 0;
      }
      @media only screen and (max-width: 600px) {
        video {
          max-width: 160px;
        }
      }
      .control-panel-wrapper {
        position: fixed;
        left: 50%;
        bottom: 24px;
        transform: translateX(-50%);
        width: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        z-index: 1100;
        pointer-events: none;
      }
      .controls-container {
        pointer-events: auto;
      }
      .recording-controls,
      .playback-controls {
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        margin-bottom: 10px;
      }
      .control-group {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .recording-controls input,
      .playback-controls select,
      .playback-controls input[type="text"] {
        padding: 5px 10px;
        border: none;
        border-radius: 3px;
        background: white;
        min-width: 150px;
      }
      .recording-controls button,
      .playback-controls button {
        padding: 5px 15px;
        border: none;
        border-radius: 3px;
        color: white;
        cursor: pointer;
        transition: background 0.3s;
      }
      .recording-controls button:disabled,
      .playback-controls button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }
      #startRecord {
        background: #4CAF50;
      }
      #startRecord:hover:not(:disabled) {
        background: #45a049;
      }
      #stopRecord {
        background: #f44336;
      }
      #stopRecord:hover:not(:disabled) {
        background: #da190b;
      }
      #deleteSign {
        background: #ff9800;
      }
      #deleteSign:hover:not(:disabled) {
        background: #f57c00;
      }
      #playbackBtn {
        background: #2196F3;
      }
      #playbackBtn:hover:not(:disabled) {
        background: #1976D2;
      }
      #stopPlaybackBtn {
        background: #FF9800;
      }
      #stopPlaybackBtn:hover:not(:disabled) {
        background: #F57C00;
      }
      .import-export-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 10px;
      }
      #importBtn, #exportBtn {
        background: #607D8B;
        color: white;
        border: none;
        border-radius: 3px;
        padding: 5px 15px;
        cursor: pointer;
        transition: background 0.3s;
      }
      #importBtn:hover:not(:disabled), #exportBtn:hover:not(:disabled) {
        background: #455A64;
      }
      #speechBtn {
        background: #9C27B0;
        color: white;
        border: none;
        border-radius: 3px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 18px;
        transition: background 0.3s;
      }
      #speechBtn:hover:not(:disabled) {
        background: #7B1FA2;
      }
      /* Playback speed control */
      .playback-speed-control {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
      }
      .playback-speed-control label {
        color: white;
        font-size: 12px;
        white-space: nowrap;
      }
      .playback-speed-control input[type="range"] {
        flex: 1;
        min-width: 100px;
        height: 6px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
        outline: none;
        -webkit-appearance: none;
      }
      .playback-speed-control input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: #2196F3;
        border-radius: 50%;
        cursor: pointer;
      }
      .playback-speed-control input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: #2196F3;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }
      .playback-speed-control .speed-value {
        color: white;
        font-size: 12px;
        min-width: 35px;
        text-align: right;
      }
      .top-right-logo {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
      }
      .top-right-logo img {
        height: 120px;
        width: auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        background: white;
        padding: 4px;
      }
      /* Back button styling */
      .back-button {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 2001;
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        padding: 10px 20px;
        border-radius: 5px;
        text-decoration: none;
        display: flex;
        align-items: center;
        font-weight: 500;
        transition: background 0.3s;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      }
      .back-button:hover {
        background: rgba(255, 255, 255, 1);
        color: #000;
        text-decoration: none;
      }
      
      /* Smartphone mode toggle button */
      .smartphone-mode-btn {
        position: fixed !important;
        top: 70px !important;
        left: 20px !important;
        z-index: 10001 !important;
        background: rgba(255, 255, 255, 0.9) !important;
        border: 2px solid #667eea !important;
        border-radius: 50% !important;
        width: 50px !important;
        height: 50px !important;
        min-width: 50px !important;
        min-height: 50px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2) !important;
        visibility: visible !important;
        opacity: 1 !important;
        pointer-events: auto !important;
        font-size: 1.5rem !important;
        color: #667eea !important;
        margin: 0 !important;
        padding: 0 !important;
        overflow: visible !important;
      }
      
      /* Ensure button is never hidden */
      button.smartphone-mode-btn,
      #smartphoneModeBtn {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      .smartphone-mode-btn:hover {
        background: #667eea !important;
        transform: scale(1.1) !important;
        color: white !important;
      }
      
      .smartphone-mode-btn.active {
        background: #667eea !important;
        color: white !important;
      }
      
      /* Smartphone mode styles - Responsive layout */
      body.smartphone-mode {
        overflow-x: hidden;
      }
      
      /* Adjust canvas and video for mobile */
      body.smartphone-mode canvas {
        max-width: 100vw !important;
        max-height: 100vh !important;
        width: 100% !important;
        height: auto !important;
      }
      
      body.smartphone-mode video {
        max-width: 100vw !important;
        max-height: 100vh !important;
        width: 100% !important;
        height: auto !important;
      }
      
      /* Responsive control panel for smartphone mode - 20% of space */
      body.smartphone-mode .control-panel-wrapper {
        bottom: 10px !important;
        left: 10px !important;
        transform: none !important;
        width: 20% !important;
        max-width: 200px !important;
        min-width: 150px !important;
      }
      
      body.smartphone-mode .controls-container {
        width: 100% !important;
      }
      
      body.smartphone-mode .recording-controls,
      body.smartphone-mode .playback-controls {
        flex-direction: column !important;
        gap: 4px !important;
        padding: 6px !important;
        width: 100% !important;
        background: rgba(0, 0, 0, 0.7) !important;
        border-radius: 4px !important;
        margin-bottom: 6px !important;
      }
      
      body.smartphone-mode .control-group {
        flex-direction: column !important;
        width: 100% !important;
        gap: 4px !important;
      }
      
      body.smartphone-mode .recording-controls input,
      body.smartphone-mode .playback-controls input[type="text"] {
        width: 100% !important;
        min-width: 100% !important;
        font-size: 10px !important;
        padding: 4px 6px !important;
      }
      
      body.smartphone-mode .recording-controls button,
      body.smartphone-mode .playback-controls button {
        width: 100% !important;
        padding: 6px 8px !important;
        font-size: 10px !important;
      }
      
      body.smartphone-mode .playback-speed-control {
        flex-direction: column !important;
        width: 100% !important;
        gap: 4px !important;
        margin-top: 4px !important;
      }
      
      body.smartphone-mode .playback-speed-control label {
        font-size: 9px !important;
      }
      
      body.smartphone-mode .playback-speed-control input[type="range"] {
        width: 100% !important;
        height: 4px !important;
      }
      
      body.smartphone-mode .playback-speed-control .speed-value {
        font-size: 9px !important;
      }
      
      body.smartphone-mode .import-export-controls {
        flex-direction: column !important;
        width: 100% !important;
        gap: 4px !important;
        margin-top: 4px !important;
      }
      
      body.smartphone-mode #importBtn,
      body.smartphone-mode #exportBtn {
        width: 100% !important;
        padding: 6px 8px !important;
        font-size: 10px !important;
      }
      
      body.smartphone-mode #speechBtn {
        padding: 4px 6px !important;
        font-size: 14px !important;
      }
      
      /* Adjust back button for smartphone mode */
      body.smartphone-mode .back-button {
        top: 10px !important;
        left: 10px !important;
        padding: 8px 16px !important;
        font-size: 12px !important;
      }
      
      /* Adjust smartphone mode button for smartphone mode */
      body.smartphone-mode .smartphone-mode-btn {
        top: 60px !important;
        left: 10px !important;
        width: 45px !important;
        height: 45px !important;
        font-size: 1.2rem !important;
      }
      
      /* Adjust YCI logo for smartphone mode */
      body.smartphone-mode .top-right-logo {
        top: 10px !important;
        right: 10px !important;
      }
      
      body.smartphone-mode .top-right-logo img {
        height: 80px !important;
      }
      
      /* Adjust preview for smartphone mode - position to avoid control panel */
      body.smartphone-mode .preview {
        bottom: 10px !important;
        right: 10px !important;
        max-width: 25% !important;
        min-width: 120px !important;
      }
      
      body.smartphone-mode .preview video {
        max-width: 100% !important;
        width: 100% !important;
      }
      
      /* Responsive media queries */
      @media (max-width: 768px) {
        .control-panel-wrapper {
          width: 20% !important;
          max-width: 200px !important;
          min-width: 150px !important;
          bottom: 10px !important;
          left: 10px !important;
          transform: none !important;
        }
        
        .recording-controls,
        .playback-controls {
          flex-direction: column !important;
          gap: 4px !important;
          padding: 6px !important;
        }
        
        .control-group {
          flex-direction: column !important;
          width: 100% !important;
          gap: 4px !important;
        }
        
        .recording-controls input,
        .playback-controls input[type="text"] {
          width: 100% !important;
          min-width: 100% !important;
          font-size: 10px !important;
          padding: 4px 6px !important;
        }
        
        .recording-controls button,
        .playback-controls button {
          width: 100% !important;
          padding: 6px 8px !important;
          font-size: 10px !important;
        }
        
        .import-export-controls {
          flex-direction: column !important;
          width: 100% !important;
          gap: 4px !important;
        }
        
        #importBtn, #exportBtn {
          width: 100% !important;
          padding: 6px 8px !important;
          font-size: 10px !important;
        }
        
        .back-button {
          top: 10px !important;
          left: 10px !important;
          padding: 8px 16px !important;
          font-size: 12px !important;
        }
        
        .smartphone-mode-btn {
          top: 60px !important;
          left: 10px !important;
          width: 45px !important;
          height: 45px !important;
          font-size: 1.2rem !important;
        }
      }
      
      /* Extra small screens */
      @media (max-width: 480px) {
        .control-panel-wrapper {
          width: 20% !important;
          max-width: 180px !important;
          min-width: 140px !important;
          bottom: 5px !important;
        }
        
        .recording-controls,
        .playback-controls {
          padding: 5px !important;
        }
        
        .recording-controls input,
        .playback-controls input[type="text"],
        .recording-controls button,
        .playback-controls button {
          font-size: 9px !important;
          padding: 4px 6px !important;
        }
        
        .back-button {
          font-size: 11px !important;
          padding: 6px 12px !important;
        }
        
        .smartphone-mode-btn {
          width: 40px !important;
          height: 40px !important;
          font-size: 1rem !important;
        }
      }
    </style>
  </head>
  <body>
    <!-- Smartphone mode toggle button -->
    <button class="smartphone-mode-btn" id="smartphoneModeBtn" title="Toggle Smartphone Mode" style="display: flex !important; visibility: visible !important; opacity: 1 !important; z-index: 10001 !important;">üì±</button>
    
    <!-- Back to Landing Page Button -->
    <a href="landing.html" class="back-button">‚Üê Back to Home</a>
    
    <div class="top-right-logo">
      <img src="./yci_logo.jpg" alt="Youth College International Logo" />
    </div>
    <div class="control-panel-wrapper">
      <div class="controls-container">
        <div class="recording-controls">
          <div class="control-group">
            <input type="text" id="signName" placeholder="Enter sign name" />
            <button id="startRecord">Start Record</button>
            <button id="stopRecord" disabled>Stop Record</button>
            <button id="deleteSign">Delete Sign</button>
          </div>
        </div>
        <div class="playback-controls">
          <div class="control-group">
            <input type="text" id="signNamePlayback" placeholder="Enter or recognize sign names, separated by spaces (e.g. hello hi thankyou)" />
            <button id="speechBtn">üé§</button>
            <button id="playbackBtn">Playback</button>
            <button id="stopPlaybackBtn" disabled>Stop Playback</button>
          </div>
          <div class="playback-speed-control">
            <label for="playbackSpeed">Speed:</label>
            <input type="range" id="playbackSpeed" min="0.25" max="2.0" step="0.25" value="1.0" />
            <span class="speed-value" id="speedValue">1.0x</span>
          </div>
        </div>
        <div class="import-export-controls">
          <button id="exportBtn">Export</button>
          <input type="file" id="importInput" accept="application/json" style="display:none;" />
          <button id="importBtn">Import</button>
        </div>
      </div>
    </div>
    <div class="preview">
      <video class="input_video" width="1280px" height="720px"></video>
      <canvas class="guides"></canvas>
      <section>
        <a href="#" onclick="return false;"><p>Live2D</p></a>
        <a class="current" href="#" onclick="return false;"><p>VRM</p></a>  
      </section>
    </div>
    <script>
      // Get Kalidokit from UMD module
      const Kalidokit = window.Kalidokit;
      
      // Import Helper Functions from Kalidokit
      const remap = Kalidokit.Utils.remap;
      const clamp = Kalidokit.Utils.clamp;
      const lerp = Kalidokit.Vector.lerp;

      /* THREEJS WORLD SETUP */
      let currentVrm;

      // renderer
      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // camera
      // Increased FOV from 35 to 45 degrees and moved camera further back to show half body
      const orbitCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      orbitCamera.position.set(0.0, 1.4, 1.5);

      // controls
      const orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement);
      orbitControls.screenSpacePanning = true;
      orbitControls.target.set(0.0, 1.4, 0.0);
      orbitControls.update();

      // scene
      const scene = new THREE.Scene();

      // light
      const light = new THREE.DirectionalLight(0xffffff);
      light.position.set(1.0, 1.0, 1.0).normalize();
      scene.add(light);

      // Main Render Loop
      const clock = new THREE.Clock();

      function animate() {
          requestAnimationFrame(animate);

          if (currentVrm) {
              // Update model to render physics
              currentVrm.update(clock.getDelta());
          }
          renderer.render(scene, orbitCamera);
      }
      animate();

      /* VRM CHARACTER SETUP */

      // Import Character VRM - using default character
      const loader = new THREE.GLTFLoader();
      loader.crossOrigin = "anonymous";
      // Load default VRM model
          loader.load(
          "./2608284133256745833.vrm",

          (gltf) => {
              THREE.VRMUtils.removeUnnecessaryJoints(gltf.scene);

              THREE.VRM.from(gltf).then((vrm) => {
                  scene.add(vrm.scene);
                  currentVrm = vrm;
                  currentVrm.scene.rotation.y = Math.PI; // Rotate model 180deg to face camera
              });
          },

          (progress) => console.log("Loading model...", 100.0 * (progress.loaded / progress.total), "%"),

          (error) => console.error(error)
      );

      // Animate Rotation Helper function
      const rigRotation = (name, rotation = { x: 0, y: 0, z: 0 }, dampener = 1, lerpAmount = 0.3) => {
          if (!currentVrm) {
              return;
          }
          const Part = currentVrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName[name]);
          if (!Part) {
              return;
          }

          let euler = new THREE.Euler(
              rotation.x * dampener,
              rotation.y * dampener,
              rotation.z * dampener,
              rotation.rotationOrder || "XYZ"
          );
          let quaternion = new THREE.Quaternion().setFromEuler(euler);
          Part.quaternion.slerp(quaternion, lerpAmount); // interpolate
      };

      // Animate Position Helper Function
      const rigPosition = (name, position = { x: 0, y: 0, z: 0 }, dampener = 1, lerpAmount = 0.3) => {
          if (!currentVrm) {
              return;
          }
          const Part = currentVrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName[name]);
          if (!Part) {
              return;
          }
          let vector = new THREE.Vector3(position.x * dampener, position.y * dampener, position.z * dampener);
          Part.position.lerp(vector, lerpAmount); // interpolate
      };

      let oldLookTarget = new THREE.Euler();
      const rigFace = (riggedFace) => {
          if (!currentVrm) {
              return;
          }
          rigRotation("Neck", riggedFace.head, 0.7);

          // Blendshapes and Preset Name Schema
          const Blendshape = currentVrm.blendShapeProxy;
          const PresetName = THREE.VRMSchema.BlendShapePresetName;

          // Simple example without winking. Interpolate based on old blendshape, then stabilize blink with `Kalidokit` helper function.
          // for VRM, 1 is closed, 0 is open.
          riggedFace.eye.l = lerp(clamp(1 - riggedFace.eye.l, 0, 1), Blendshape.getValue(PresetName.Blink), 0.5);
          riggedFace.eye.r = lerp(clamp(1 - riggedFace.eye.r, 0, 1), Blendshape.getValue(PresetName.Blink), 0.5);
          riggedFace.eye = Kalidokit.Face.stabilizeBlink(riggedFace.eye, riggedFace.head.y);
          Blendshape.setValue(PresetName.Blink, riggedFace.eye.l);

          // Interpolate and set mouth blendshapes
          Blendshape.setValue(PresetName.I, lerp(riggedFace.mouth.shape.I, Blendshape.getValue(PresetName.I), 0.5));
          Blendshape.setValue(PresetName.A, lerp(riggedFace.mouth.shape.A, Blendshape.getValue(PresetName.A), 0.5));
          Blendshape.setValue(PresetName.E, lerp(riggedFace.mouth.shape.E, Blendshape.getValue(PresetName.E), 0.5));
          Blendshape.setValue(PresetName.O, lerp(riggedFace.mouth.shape.O, Blendshape.getValue(PresetName.O), 0.5));
          Blendshape.setValue(PresetName.U, lerp(riggedFace.mouth.shape.U, Blendshape.getValue(PresetName.U), 0.5));

          //PUPILS
          //interpolate pupil and keep a copy of the value
          let lookTarget = new THREE.Euler(
              lerp(oldLookTarget.x, riggedFace.pupil.y, 0.4),
              lerp(oldLookTarget.y, riggedFace.pupil.x, 0.4),
              0,
              "XYZ"
          );
          oldLookTarget.copy(lookTarget);
          currentVrm.lookAt.applyer.lookAt(lookTarget);
      };

      /* VRM Character Animator */
      const animateVRM = (vrm, results) => {
          if (!vrm) {
              return;
          }
          // Take the results from `Holistic` and animate character based on its Face, Pose, and Hand Keypoints.
          let riggedPose, riggedLeftHand, riggedRightHand, riggedFace;

          const faceLandmarks = results.faceLandmarks;
          // Pose 3D Landmarks are with respect to Hip distance in meters
          const pose3DLandmarks = results.ea;
          // Pose 2D landmarks are with respect to videoWidth and videoHeight
          const pose2DLandmarks = results.poseLandmarks;
          // Be careful, hand landmarks may be reversed
          const leftHandLandmarks = results.rightHandLandmarks;
          const rightHandLandmarks = results.leftHandLandmarks;

          // Animate Face
          if (faceLandmarks) {
              riggedFace = Kalidokit.Face.solve(faceLandmarks, {
                  runtime: "mediapipe",
                  video: videoElement,
              });
              rigFace(riggedFace);
          }

          // Animate Pose
          if (pose2DLandmarks && pose3DLandmarks) {
              riggedPose = Kalidokit.Pose.solve(pose3DLandmarks, pose2DLandmarks, {
                  runtime: "mediapipe",
                  video: videoElement,
              });
              rigRotation("Hips", riggedPose.Hips.rotation, 0.7);
              rigPosition(
                  "Hips",
                  {
                      x: riggedPose.Hips.position.x, // Reverse direction
                      y: riggedPose.Hips.position.y + 1, // Add a bit of height
                      z: -riggedPose.Hips.position.z, // Reverse direction
                  },
                  1,
                  0.07
              );

              rigRotation("Chest", riggedPose.Spine, 0.25, 0.3);
              rigRotation("Spine", riggedPose.Spine, 0.45, 0.3);

              rigRotation("RightUpperArm", riggedPose.RightUpperArm, 1, 0.3);
              rigRotation("RightLowerArm", riggedPose.RightLowerArm, 1, 0.3);
              rigRotation("LeftUpperArm", riggedPose.LeftUpperArm, 1, 0.3);
              rigRotation("LeftLowerArm", riggedPose.LeftLowerArm, 1, 0.3);

              rigRotation("LeftUpperLeg", riggedPose.LeftUpperLeg, 1, 0.3);
              rigRotation("LeftLowerLeg", riggedPose.LeftLowerLeg, 1, 0.3);
              rigRotation("RightUpperLeg", riggedPose.RightUpperLeg, 1, 0.3);
              rigRotation("RightLowerLeg", riggedPose.RightLowerLeg, 1, 0.3);
          }

          // Animate Hands
          if (leftHandLandmarks) {
              riggedLeftHand = Kalidokit.Hand.solve(leftHandLandmarks, "Left");
              rigRotation("LeftHand", {
                  // Combine pose rotation Z and hand rotation X Y
                  z: riggedPose.LeftHand.z,
                  y: riggedLeftHand.LeftWrist.y,
                  x: riggedLeftHand.LeftWrist.x,
              });
              rigRotation("LeftRingProximal", riggedLeftHand.LeftRingProximal);
              rigRotation("LeftRingIntermediate", riggedLeftHand.LeftRingIntermediate);
              rigRotation("LeftRingDistal", riggedLeftHand.LeftRingDistal);
              rigRotation("LeftIndexProximal", riggedLeftHand.LeftIndexProximal);
              rigRotation("LeftIndexIntermediate", riggedLeftHand.LeftIndexIntermediate);
              rigRotation("LeftIndexDistal", riggedLeftHand.LeftIndexDistal);
              rigRotation("LeftMiddleProximal", riggedLeftHand.LeftMiddleProximal);
              rigRotation("LeftMiddleIntermediate", riggedLeftHand.LeftMiddleIntermediate);
              rigRotation("LeftMiddleDistal", riggedLeftHand.LeftMiddleDistal);
              rigRotation("LeftThumbProximal", riggedLeftHand.LeftThumbProximal);
              rigRotation("LeftThumbIntermediate", riggedLeftHand.LeftThumbIntermediate);
              rigRotation("LeftThumbDistal", riggedLeftHand.LeftThumbDistal);
              rigRotation("LeftLittleProximal", riggedLeftHand.LeftLittleProximal);
              rigRotation("LeftLittleIntermediate", riggedLeftHand.LeftLittleIntermediate);
              rigRotation("LeftLittleDistal", riggedLeftHand.LeftLittleDistal);
          }
          if (rightHandLandmarks) {
              riggedRightHand = Kalidokit.Hand.solve(rightHandLandmarks, "Right");
              rigRotation("RightHand", {
                  // Combine Z axis from pose hand and X/Y axis from hand wrist rotation
                  z: riggedPose.RightHand.z,
                  y: riggedRightHand.RightWrist.y,
                  x: riggedRightHand.RightWrist.x,
              });
              rigRotation("RightRingProximal", riggedRightHand.RightRingProximal);
              rigRotation("RightRingIntermediate", riggedRightHand.RightRingIntermediate);
              rigRotation("RightRingDistal", riggedRightHand.RightRingDistal);
              rigRotation("RightIndexProximal", riggedRightHand.RightIndexProximal);
              rigRotation("RightIndexIntermediate", riggedRightHand.RightIndexIntermediate);
              rigRotation("RightIndexDistal", riggedRightHand.RightIndexDistal);
              rigRotation("RightMiddleProximal", riggedRightHand.RightMiddleProximal);
              rigRotation("RightMiddleIntermediate", riggedRightHand.RightMiddleIntermediate);
              rigRotation("RightMiddleDistal", riggedRightHand.RightMiddleDistal);
              rigRotation("RightThumbProximal", riggedRightHand.RightThumbProximal);
              rigRotation("RightThumbIntermediate", riggedRightHand.RightThumbIntermediate);
              rigRotation("RightThumbDistal", riggedRightHand.RightThumbDistal);
              rigRotation("RightLittleProximal", riggedRightHand.RightLittleProximal);
              rigRotation("RightLittleIntermediate", riggedRightHand.RightLittleIntermediate);
              rigRotation("RightLittleDistal", riggedRightHand.RightLittleDistal);
          }
      };

      /* SETUP MEDIAPIPE HOLISTIC INSTANCE */
      let videoElement = document.querySelector(".input_video"),
          guideCanvas = document.querySelector("canvas.guides");

      const onResults = (results) => {
          // Draw landmark guides
          drawResults(results);
          // Animate model
          animateVRM(currentVrm, results);

          // Record landmarks if recording is active
          if (isRecording) {
              const timestamp = Date.now() - recordingStartTime;
              recordedData.push({
                  timestamp,
                  faceLandmarks: results.faceLandmarks,
                  poseLandmarks: results.poseLandmarks,
                  pose3DLandmarks: results.ea,
                  leftHandLandmarks: results.leftHandLandmarks,
                  rightHandLandmarks: results.rightHandLandmarks
              });
          }
      };

      const holistic = new Holistic({
          locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/${file}`;
          },
      });

      holistic.setOptions({
          modelComplexity: 1,
          smoothLandmarks: true,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.7,
          refineFaceLandmarks: true,
      });
      // Pass holistic a callback function
      holistic.onResults(onResults);

      const drawResults = (results) => {
          guideCanvas.width = videoElement.videoWidth;
          guideCanvas.height = videoElement.videoHeight;
          let canvasCtx = guideCanvas.getContext("2d");
          canvasCtx.save();
          canvasCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
          // Use `Mediapipe` drawing functions
          drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {
              color: "#00cff7",
              lineWidth: 4,
          });
          drawLandmarks(canvasCtx, results.poseLandmarks, {
              color: "#ff0364",
              lineWidth: 2,
          });
          drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {
              color: "#C0C0C070",
              lineWidth: 1,
          });
          if (results.faceLandmarks && results.faceLandmarks.length === 478) {
              //draw pupils
              drawLandmarks(canvasCtx, [results.faceLandmarks[468], results.faceLandmarks[468 + 5]], {
                  color: "#ffe603",
                  lineWidth: 2,
              });
          }
          drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {
              color: "#eb1064",
              lineWidth: 5,
          });
          drawLandmarks(canvasCtx, results.leftHandLandmarks, {
              color: "#00cff7",
              lineWidth: 2,
          });
          drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {
              color: "#22c3e3",
              lineWidth: 5,
          });
          drawLandmarks(canvasCtx, results.rightHandLandmarks, {
              color: "#ff0364",
              lineWidth: 2,
          });
      };

      // Use `Mediapipe` utils to get camera - lower resolution = higher fps
      const camera = new Camera(videoElement, {
          onFrame: async () => {
              await holistic.send({ image: videoElement });
          },
          width: 640,
          height: 480,
      });
      camera.start();

      // IndexedDB setup
      const dbName = "signLanguageDB";
      const storeName = "signRecordings";
      let db;

      // Initialize IndexedDB
      const initDB = () => {
          return new Promise((resolve, reject) => {
              // Use version 2 to match existing database, or higher if needed
              const request = indexedDB.open(dbName, 2);

              request.onerror = (event) => {
                  console.error("Error opening database:", event.target.error);
                  reject(event.target.error);
              };

              request.onsuccess = (event) => {
                  db = event.target.result;
                  console.log("Database opened successfully");
                  resolve(db);
              };

              request.onupgradeneeded = (event) => {
                  const db = event.target.result;
                  // Create object store if it doesn't exist
                  if (!db.objectStoreNames.contains(storeName)) {
                      db.createObjectStore(storeName, { keyPath: "id", autoIncrement: true });
                  }
                  // If upgrading from version 1, the store should already exist
                  // Just ensure it's accessible
              };
          });
      };

      // Recording state
      let isRecording = false;
      let recordedData = [];
      let recordingStartTime;

      // Save recording to IndexedDB
      const saveRecording = async (signName, data) => {
          return new Promise((resolve, reject) => {
              const transaction = db.transaction([storeName], "readwrite");
              const store = transaction.objectStore(storeName);
              
              const recording = {
                  signName,
                  data,
                  timestamp: new Date().toISOString()
              };

              const request = store.add(recording);

              request.onsuccess = () => {
                  console.log("Recording saved successfully");
                  resolve();
              };

              request.onerror = (event) => {
                  console.error("Error saving recording:", event.target.error);
                  reject(event.target.error);
              };
          });
      };

      // Initialize recording controls
      const initRecordingControls = () => {
          const startButton = document.getElementById("startRecord");
          const stopButton = document.getElementById("stopRecord");
          const signNameInput = document.getElementById("signName");

          startButton.addEventListener("click", () => {
              if (!signNameInput.value.trim()) {
                  alert("Please enter a sign name");
                  return;
              }
              isRecording = true;
              recordedData = [];
              recordingStartTime = Date.now();
              startButton.disabled = true;
              stopButton.disabled = false;
              signNameInput.disabled = true;
          });

          stopButton.addEventListener("click", async () => {
              isRecording = false;
              startButton.disabled = false;
              stopButton.disabled = true;
              signNameInput.disabled = false;

              try {
                  // Check if database is available, initialize if needed
                  if (!db) {
                      console.log("Database not available, attempting to initialize...");
                      await initDB();
                  }
                  
                  // Check if we have recorded data
                  if (recordedData.length === 0) {
                      alert("No data recorded. Please make sure your camera is working and try again.");
                      return;
                  }
                  
                  console.log("Saving recording with", recordedData.length, "frames");
                  await saveRecording(signNameInput.value.trim(), recordedData);
                  alert("Recording saved successfully!");
              } catch (error) {
                  console.error("Error saving recording:", error);
                  alert("Error saving recording: " + error.message);
              }
          });
          
          // Delete sign button functionality
          const deleteButton = document.getElementById("deleteSign");
          deleteButton.addEventListener("click", async () => {
              try {
                  // Check if database is available, initialize if needed
                  if (!db) {
                      console.log("Database not available, attempting to initialize...");
                      await initDB();
                  }
                  
                  // Get all recordings from database
                  const transaction = db.transaction([storeName], "readonly");
                  const store = transaction.objectStore(storeName);
                  const getAllRequest = store.getAll();
                  
                  getAllRequest.onsuccess = () => {
                      const recordings = getAllRequest.result;
                      
                      if (recordings.length === 0) {
                          alert("No sign language data found in database.");
                          return;
                      }
                      
                      // Create a list of sign names for user to choose from
                      const signNames = recordings.map(r => r.signName).filter(Boolean);
                      const uniqueSignNames = [...new Set(signNames)];
                      
                      if (uniqueSignNames.length === 0) {
                          alert("No sign names found in database.");
                          return;
                      }
                      
                      // Show prompt with available sign names
                      const signList = uniqueSignNames.map((name, index) => `${index + 1}. ${name}`).join('\n');
                      const userInput = prompt(`Enter the sign name to delete:\n\nAvailable signs:\n${signList}\n\nType the exact sign name:`);
                      
                      if (!userInput || !userInput.trim()) {
                          return; // User cancelled or entered nothing
                      }
                      
                      const signNameToDelete = userInput.trim();
                      
                      // Confirm deletion
                      if (!confirm(`Are you sure you want to delete "${signNameToDelete}"? This action cannot be undone.`)) {
                          return;
                      }
                      
                      // Delete all recordings with matching sign name
                      const deleteTransaction = db.transaction([storeName], "readwrite");
                      const deleteStore = deleteTransaction.objectStore(storeName);
                      
                      let deletedCount = 0;
                      let deletePromises = [];
                      
                      recordings.forEach(recording => {
                          if (recording.signName && recording.signName.toLowerCase() === signNameToDelete.toLowerCase()) {
                              const deleteRequest = deleteStore.delete(recording.id);
                              deletePromises.push(
                                  new Promise((resolve, reject) => {
                                      deleteRequest.onsuccess = () => {
                                          deletedCount++;
                                          resolve();
                                      };
                                      deleteRequest.onerror = () => {
                                          reject(deleteRequest.error);
                                      };
                                  })
                              );
                          }
                      });
                      
                      Promise.all(deletePromises)
                          .then(() => {
                              if (deletedCount > 0) {
                                  alert(`Successfully deleted "${signNameToDelete}" (${deletedCount} recording(s) removed).`);
                              } else {
                                  alert(`No recordings found with the sign name "${signNameToDelete}".`);
                              }
                          })
                          .catch((error) => {
                              console.error("Error deleting recording:", error);
                              alert("Error deleting recording: " + error.message);
                          });
                  };
                  
                  getAllRequest.onerror = () => {
                      console.error("Error getting recordings:", getAllRequest.error);
                      alert("Error accessing database: " + getAllRequest.error);
                  };
              } catch (error) {
                  console.error("Error in delete operation:", error);
                  alert("Error deleting sign: " + error.message);
              }
          });
      };

      // Playback state
      let isPlaybackActive = false;
      let playbackData = null;
      let playbackStartTime = 0;
      let playbackFrameIndex = 0;
      let originalOnResults = null;
      let playbackInterval = null;
      let playbackSpeed = 1.0; // Default playback speed (1.0 = normal speed)

      // Stop playback and resume real-time tracking
      const stopPlayback = () => {
          if (!isPlaybackActive) return;
          isPlaybackActive = false;
          playbackData = null;
          playbackFrameIndex = 0;
          if (playbackInterval) {
              clearInterval(playbackInterval);
              playbackInterval = null;
          }
          if (originalOnResults) {
              holistic.onResults = originalOnResults;
          }
          document.getElementById("startRecord").disabled = false;
          document.getElementById("stopRecord").disabled = true;
          document.getElementById("signName").disabled = false;
          document.getElementById("signNamePlayback").disabled = false;
          document.getElementById("speechBtn").disabled = false;
          document.getElementById("playbackBtn").disabled = false;
          document.getElementById("stopPlaybackBtn").disabled = true;
          camera.start();
      };

      // Start playback of multiple sign names in sequence
      const startPlaybackByNames = async (signNames) => {
          if (isPlaybackActive) return;
          if (!signNames.length) {
              alert("Please enter or recognize at least one sign name to play");
              return;
          }
          const transaction = db.transaction([storeName], "readonly");
          const store = transaction.objectStore(storeName);
          const request = store.getAll();
          request.onsuccess = () => {
              const recordings = request.result;
              // Prepare playback queue
              const queue = [];
              const notFound = [];
              const foundNames = new Set(); // Track found names to avoid duplicates
              
              signNames.forEach(name => {
                  const trimmedName = name.trim();
                  if (!trimmedName || foundNames.has(trimmedName.toLowerCase())) {
                      return; // Skip empty or already found names
                  }
                  
                  const rec = recordings.find(r => {
                      if (!r.signName) return false;
                      // Exact match (case-insensitive)
                      return r.signName.toLowerCase() === trimmedName.toLowerCase();
                  });
                  
                  if (rec) {
                      queue.push(rec);
                      foundNames.add(trimmedName.toLowerCase());
                  } else {
                      notFound.push(trimmedName);
                  }
              });
              
              if (!queue.length) {
                  alert("No matching recordings found for the given sign names.");
                  return;
              }
              // Start sequential playback
              let currentIdx = 0;
              const playNext = () => {
                  if (currentIdx >= queue.length) {
                      stopPlayback();
                      if (notFound.length) {
                          alert("Some sign(s) not found: " + notFound.join(", "));
                      }
                      return;
                  }
                  const recording = queue[currentIdx];
                  isPlaybackActive = true;
                  playbackData = recording.data;
                  playbackStartTime = Date.now();
                  playbackFrameIndex = 0;
                  document.getElementById("startRecord").disabled = true;
                  document.getElementById("stopRecord").disabled = true;
                  document.getElementById("signName").disabled = true;
                  document.getElementById("signNamePlayback").disabled = false;
                  document.getElementById("speechBtn").disabled = true;
                  document.getElementById("playbackBtn").disabled = true;
                  document.getElementById("stopPlaybackBtn").disabled = false;
                  camera.stop();
                  if (playbackInterval) clearInterval(playbackInterval);
                  
                  // Calculate interval based on playback speed (33ms = ~30 FPS at 1x speed)
                  const baseInterval = 33;
                  const currentInterval = baseInterval / playbackSpeed;
                  
                  playbackInterval = setInterval(() => {
                      if (!isPlaybackActive || playbackFrameIndex >= playbackData.length) {
                          clearInterval(playbackInterval);
                          playbackInterval = null;
                          currentIdx++;
                          playNext();
                          return;
                      }
                      const currentFrame = playbackData[playbackFrameIndex];
                      const playbackResults = {
                          faceLandmarks: currentFrame.faceLandmarks,
                          poseLandmarks: currentFrame.poseLandmarks,
                          ea: currentFrame.pose3DLandmarks,
                          leftHandLandmarks: currentFrame.leftHandLandmarks,
                          rightHandLandmarks: currentFrame.rightHandLandmarks
                      };
                      drawResults(playbackResults);
                      animateVRM(currentVrm, playbackResults);
                      playbackFrameIndex++;
                  }, currentInterval);
              };
              playNext();
          };
      };

      // Update playback controls to use multi-name logic
      const initPlaybackControls = () => {
          const playbackBtn = document.getElementById("playbackBtn");
          const stopPlaybackBtn = document.getElementById("stopPlaybackBtn");
          const signNamePlayback = document.getElementById("signNamePlayback");
          const speechBtn = document.getElementById("speechBtn");

          playbackBtn.addEventListener("click", async () => {
              const inputValue = signNamePlayback.value.trim();
              if (!inputValue) {
                  alert("Please enter a sign name to play");
                  return;
              }
              
              // Get all recordings from database first to check for phrases
              const transaction = db.transaction([storeName], "readonly");
              const store = transaction.objectStore(storeName);
              const getAllRequest = store.getAll();
              
              getAllRequest.onsuccess = () => {
                  const allRecordings = getAllRequest.result;
                  const allSignNames = allRecordings.map(r => r.signName ? r.signName.toLowerCase() : '').filter(Boolean);
                  
                  // Smart parsing: try to match phrases first, then individual words
                  let names = [];
                  
                  if (inputValue.includes(' ')) {
                      // Input has spaces - try to match phrases intelligently
                      const words = inputValue.split(/\s+/).map(s => s.trim()).filter(Boolean);
                      
                      // First, try exact match
                      if (allSignNames.includes(inputValue.toLowerCase())) {
                          names.push(inputValue);
                      } else {
                          // Greedy matching: try to find longest phrases first
                          let i = 0;
                          while (i < words.length) {
                              let found = false;
                              // Try phrases of decreasing length (longest first) starting from current position
                              for (let len = Math.min(words.length - i, 5); len >= 1; len--) {
                                  const phrase = words.slice(i, i + len).join(' ');
                                  if (allSignNames.includes(phrase.toLowerCase())) {
                                      names.push(phrase);
                                      i += len; // Skip the words we just matched
                                      found = true;
                                      break;
                                  }
                              }
                              if (!found) {
                                  // No phrase found starting at this position, try single word
                                  if (allSignNames.includes(words[i].toLowerCase())) {
                                      names.push(words[i]);
                                  }
                                  i++;
                              }
                          }
                      }
                  } else {
                      // Single word
                      names = [inputValue];
                  }
                  
                  if (names.length === 0) {
                      alert("No matching recordings found for: " + inputValue);
                      return;
                  }
                  
                  startPlaybackByNames(names);
              };
          });
          stopPlaybackBtn.addEventListener("click", stopPlayback);

          // Initialize playback speed control
          const playbackSpeedSlider = document.getElementById("playbackSpeed");
          const speedValueDisplay = document.getElementById("speedValue");
          if (playbackSpeedSlider && speedValueDisplay) {
              // Update display when slider changes
              playbackSpeedSlider.addEventListener("input", (e) => {
                  playbackSpeed = parseFloat(e.target.value);
                  speedValueDisplay.textContent = playbackSpeed.toFixed(2) + "x";
                  
                  // If playback is active, update the interval
                  if (isPlaybackActive && playbackInterval) {
                      clearInterval(playbackInterval);
                      const baseInterval = 33;
                      const currentInterval = baseInterval / playbackSpeed;
                      playbackInterval = setInterval(() => {
                          if (!isPlaybackActive || !playbackData || playbackFrameIndex >= playbackData.length) {
                              clearInterval(playbackInterval);
                              playbackInterval = null;
                              return;
                          }
                          const currentFrame = playbackData[playbackFrameIndex];
                          if (!currentFrame) {
                              playbackFrameIndex++;
                              return;
                          }
                          const playbackResults = {
                              faceLandmarks: currentFrame.faceLandmarks,
                              poseLandmarks: currentFrame.poseLandmarks,
                              ea: currentFrame.pose3DLandmarks,
                              leftHandLandmarks: currentFrame.leftHandLandmarks,
                              rightHandLandmarks: currentFrame.rightHandLandmarks
                          };
                          drawResults(playbackResults);
                          animateVRM(currentVrm, playbackResults);
                          playbackFrameIndex++;
                      }, currentInterval);
                  }
              });
              
              // Set initial display
              speedValueDisplay.textContent = playbackSpeed.toFixed(2) + "x";
          }

          // Speech recognition for microphone button
          let recognition = null;
          if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
              const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
              recognition = new SpeechRecognition();
              recognition.continuous = false;
              recognition.interimResults = false;
              recognition.lang = 'zh-HK'; // Cantonese (Hong Kong)

              recognition.onresult = (event) => {
                  const transcript = event.results[0][0].transcript;
                  // Remove full stop (period) and comma from transcript
                  signNamePlayback.value = transcript.trim().replace(/[.,]/g, '');
              };

              recognition.onerror = (event) => {
                  console.error("Speech recognition error:", event.error);
                  alert("Speech recognition error: " + event.error);
              };
          }

          speechBtn.addEventListener("click", () => {
              if (recognition) {
                  try {
                      recognition.start();
                      speechBtn.textContent = "üé§...";
                      speechBtn.disabled = true;
                      recognition.onend = () => {
                          speechBtn.textContent = "üé§";
                          speechBtn.disabled = false;
                      };
                  } catch (error) {
                      console.error("Error starting speech recognition:", error);
                      alert("Speech recognition not available. Please enter sign names manually.");
                  }
              } else {
                  alert("Speech recognition not supported in this browser. Please enter sign names manually.");
              }
          });
      };

      // Export all recordings as JSON
      const exportRecordings = () => {
          const transaction = db.transaction([storeName], "readonly");
          const store = transaction.objectStore(storeName);
          const request = store.getAll();
          request.onsuccess = () => {
              const data = request.result;
              const json = JSON.stringify(data, null, 2);
              const blob = new Blob([json], { type: "application/json" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "sign_recordings.json";
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
          };
      };

      // Import recordings from JSON file
      const importRecordings = (file) => {
          const reader = new FileReader();
          reader.onload = async (event) => {
              try {
                  const importedData = JSON.parse(event.target.result);
                  if (!Array.isArray(importedData)) {
                      alert("Invalid file format.");
                      return;
                  }
                  
                  // Check if database is available, initialize if needed
                  if (!db) {
                      console.log("Database not available, attempting to initialize...");
                      await initDB();
                  }
                  
                  // Get all existing recordings to check for duplicates (without using index)
                  const readTransaction = db.transaction([storeName], "readonly");
                  const readStore = readTransaction.objectStore(storeName);
                  const getAllRequest = readStore.getAll();
                  
                  getAllRequest.onsuccess = () => {
                      const existingRecordings = getAllRequest.result;
                      const existingSignNames = new Set(
                          existingRecordings.map(r => r.signName ? r.signName.toLowerCase() : '').filter(Boolean)
                      );
                      
                      const writeTransaction = db.transaction([storeName], "readwrite");
                      const writeStore = writeTransaction.objectStore(storeName);
                      let importedCount = 0;
                      let skippedCount = 0;
                      let processed = 0;
                      const total = importedData.length;
                      
                      importedData.forEach((recording) => {
                          // Check for duplicate by signName (case-insensitive)
                          const signName = recording.signName ? recording.signName.toLowerCase() : '';
                          if (signName && existingSignNames.has(signName)) {
                              skippedCount++;
                              processed++;
                              if (processed === total) {
                                  alert(`Imported ${importedCount} new recordings. ${skippedCount} duplicate(s) skipped.`);
                              }
                          } else {
                              const addRequest = writeStore.add(recording);
                              addRequest.onsuccess = () => {
                                  if (signName) {
                                      existingSignNames.add(signName);
                                  }
                                  importedCount++;
                                  processed++;
                                  if (processed === total) {
                                      alert(`Imported ${importedCount} new recordings. ${skippedCount} duplicate(s) skipped.`);
                                  }
                              };
                              addRequest.onerror = () => {
                                  processed++;
                                  if (processed === total) {
                                      alert(`Imported ${importedCount} new recordings. ${skippedCount} duplicate(s) skipped.`);
                                  }
                              };
                          }
                      });
                  };
                  
                  getAllRequest.onerror = () => {
                      console.error("Error reading existing recordings:", getAllRequest.error);
                      alert("Failed to import: " + getAllRequest.error.message);
                  };
              } catch (e) {
                  alert("Failed to import: " + e.message);
              }
          };
          reader.readAsText(file);
      };

      // Initialize import/export controls
      const initImportExportControls = () => {
          const exportBtn = document.getElementById("exportBtn");
          const importBtn = document.getElementById("importBtn");
          const importInput = document.getElementById("importInput");

          exportBtn.addEventListener("click", exportRecordings);
          importBtn.addEventListener("click", () => importInput.click());
          importInput.addEventListener("change", (e) => {
              if (importInput.files && importInput.files[0]) {
                  importRecordings(importInput.files[0]);
                  importInput.value = "";
              }
          });
      };

      // Handle window resize
      window.addEventListener("resize", () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
          orbitCamera.aspect = window.innerWidth / window.innerHeight;
          orbitCamera.updateProjectionMatrix();
      });

      // Initialize the application
      (async () => {
          try {
              await initDB();
              console.log("Database initialized successfully");
          } catch (error) {
              console.error("Database initialization error:", error);
              // Try to delete and recreate the database if version mismatch
              if (error.name === 'VersionError') {
                  console.log("Attempting to delete and recreate database...");
                  try {
                      const deleteRequest = indexedDB.deleteDatabase(dbName);
                      deleteRequest.onsuccess = async () => {
                          console.log("Database deleted, recreating...");
                          try {
                              await initDB();
                              console.log("Database recreated successfully");
                          } catch (e) {
                              console.error("Failed to recreate database:", e);
                          }
                      };
                      deleteRequest.onerror = (e) => {
                          console.error("Failed to delete database:", e);
                      };
                  } catch (e) {
                      console.error("Error deleting database:", e);
                  }
              }
          }
          
          // Initialize controls even if database fails (user can still try to record)
          try {
              initRecordingControls();
              initPlaybackControls();
              initImportExportControls();
              console.log("Controls initialized successfully");
              
              // Wait for database to be ready, then auto-import default model if selected
              (async () => {
                  if (!db) {
                      await initDB();
                  }
                  // Wait a bit longer to ensure database is fully ready
                  setTimeout(() => {
                      autoImportDefaultModel().catch(err => {
                          console.error("Auto-import error:", err);
                          // Retry after a delay
                          setTimeout(() => autoImportDefaultModel(), 1000);
                      });
                  }, 1000);
              })();
          } catch (error) {
              console.error("Controls initialization error:", error);
          }
      })();
      
      // Clear database function
      async function clearDatabase() {
          return new Promise((resolve, reject) => {
              if (!db) {
                  reject(new Error("Database not initialized"));
                  return;
              }
              const transaction = db.transaction([storeName], "readwrite");
              const store = transaction.objectStore(storeName);
              const clearRequest = store.clear();
              clearRequest.onsuccess = () => {
                  console.log("‚úÖ Database cleared");
                  resolve();
              };
              clearRequest.onerror = () => {
                  console.error("Error clearing database");
                  reject(clearRequest.error);
              };
          });
      }
      
      // Auto-import default model function - uses same approach as manual import
      async function autoImportDefaultModel() {
          try {
              const selectedModel = localStorage.getItem('selectedModel') || 'default';
              const modelProcessed = localStorage.getItem('modelProcessed');
              
              // Check if we need to process the model
              if (!modelProcessed || modelProcessed !== selectedModel) {
                  // Ensure database is ready
                  if (!db) {
                      await initDB();
                  }
                  
                  if (selectedModel === 'default') {
                      // Clear database first
                      await clearDatabase();
                      
                      // Fetch and import default model directly (same as manual import)
                      try {
                          const response = await fetch('./default_model.json');
                          if (!response.ok) {
                              throw new Error('Failed to fetch default_model.json');
                          }
                          const importedData = await response.json();
                          
                          if (!Array.isArray(importedData)) {
                              console.error("Invalid file format.");
                              return;
                          }
                          
                          if (!db) {
                              console.error("Database not initialized");
                              return;
                          }
                          
                          const transaction = db.transaction([storeName], "readwrite");
                          const store = transaction.objectStore(storeName);
                          
                          let importedCount = 0;
                          let processed = 0;
                          const total = importedData.length;
                          
                          return new Promise((resolve) => {
                              if (total === 0) {
                                  localStorage.setItem('modelProcessed', 'default');
                                  console.log("‚úÖ Default model imported: 0 recordings (empty file)");
                                  resolve();
                                  return;
                              }
                              
                              importedData.forEach((recording) => {
                                  const addRequest = store.add(recording);
                                  addRequest.onsuccess = () => {
                                      importedCount++;
                                      processed++;
                                      if (processed === total) {
                                          localStorage.setItem('modelProcessed', 'default');
                                          console.log(`‚úÖ Default model imported: ${importedCount} recordings loaded.`);
                                          resolve();
                                      }
                                  };
                                  addRequest.onerror = (e) => {
                                      processed++;
                                      console.warn("Error adding recording:", e);
                                      if (processed === total) {
                                          localStorage.setItem('modelProcessed', 'default');
                                          console.log(`‚úÖ Default model import completed: ${importedCount} recordings loaded.`);
                                          resolve();
                                      }
                                  };
                              });
                          });
                      } catch (error) {
                          console.error("Error fetching/importing default model:", error);
                      }
                  } else if (selectedModel === 'blank') {
                      // Clear database for blank model
                      await clearDatabase();
                      localStorage.setItem('modelProcessed', 'blank');
                      console.log("‚úÖ Database cleared for blank model");
                  }
              }
          } catch (error) {
              console.error("Error auto-importing default model:", error);
          }
      }
    </script>
    
    <!-- Smartphone Mode Toggle Script -->
    <script>
      // Smartphone mode toggle functionality - run immediately
      (function() {
        // Function to ensure button is visible
        function ensureButtonVisible() {
          const smartphoneModeBtn = document.getElementById('smartphoneModeBtn');
          if (smartphoneModeBtn) {
            smartphoneModeBtn.style.setProperty('display', 'flex', 'important');
            smartphoneModeBtn.style.setProperty('visibility', 'visible', 'important');
            smartphoneModeBtn.style.setProperty('opacity', '1', 'important');
            smartphoneModeBtn.style.setProperty('z-index', '10001', 'important');
            smartphoneModeBtn.style.setProperty('position', 'fixed', 'important');
            smartphoneModeBtn.style.setProperty('top', '70px', 'important');
            smartphoneModeBtn.style.setProperty('left', '20px', 'important');
          }
        }
        
        // Run immediately and also on DOM ready
        ensureButtonVisible();
        
        // Ensure button is visible on load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', function() {
            ensureButtonVisible();
            initSmartphoneMode();
          });
        } else {
          ensureButtonVisible();
          initSmartphoneMode();
        }
        
        // Keep button visible (check periodically)
        setInterval(ensureButtonVisible, 500);
        
        // Also check after a short delay
        setTimeout(ensureButtonVisible, 100);
        setTimeout(ensureButtonVisible, 500);
        setTimeout(ensureButtonVisible, 1000);
        
        function initSmartphoneMode() {
          const smartphoneModeBtn = document.getElementById('smartphoneModeBtn');
          const body = document.body;
          
          if (!smartphoneModeBtn) {
            console.error('Smartphone mode button not found');
            // Try again after a delay
            setTimeout(function() {
              const btn = document.getElementById('smartphoneModeBtn');
              if (btn) {
                ensureButtonVisible();
                initSmartphoneMode();
              }
            }, 500);
            return;
          }
          
          // Ensure visible before doing anything else
          ensureButtonVisible();
          
          // Check for saved preference
          const savedMode = localStorage.getItem('smartphoneMode');
          if (savedMode === 'true') {
            body.classList.add('smartphone-mode');
            smartphoneModeBtn.classList.add('active');
          }
          
          // Toggle smartphone mode
          smartphoneModeBtn.addEventListener('click', function() {
            body.classList.toggle('smartphone-mode');
            smartphoneModeBtn.classList.toggle('active');
            
            // Save preference
            const isActive = body.classList.contains('smartphone-mode');
            localStorage.setItem('smartphoneMode', isActive);
            
            // Ensure button stays visible after toggle
            ensureButtonVisible();
          });
        }
      })();
    </script>
  </body>
</html>
