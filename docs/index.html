<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- HTML Meta Tags -->
    <title>Kalidoface 3D - Face & Full Body Tracking</title>
    <meta
      name="description"
      content="Animate character faces, poses and fingers in 3D using just your browser webcam!"
    />

    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="https://3d.kalidoface.com/" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="Kalidoface 3D - Face & Full Body Tracking"
    />
    <meta
      property="og:description"
      content="Animate character faces, poses and fingers in 3D using just your browser webcam!"
    />
    <meta
      property="og:image"
      content="https://yeemachine.github.io/k2021/favicon/kalidoface3d/meta.jpg"
    />

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="3d.kalidoface.com" />
    <meta property="twitter:url" content="https://3d.kalidoface.com/" />
    <meta
      name="twitter:title"
      content="Kalidoface 3D - Face & Full Body Tracking"
    />
    <meta
      name="twitter:description"
      content="Animate character faces, poses and fingers in 3D using just your browser webcam!"
    />
    <meta
      name="twitter:image"
      content="https://yeemachine.github.io/k2021/favicon/kalidoface3d/meta.jpg"
    />

    <link rel="manifest" href="./manifest.json" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="viewport-fit=cover, user-scalable=yes, width=device-width, initial-scale=1, maximum-scale=5">

    <meta name="theme-color" content="#16161d" />
    <base href="%PUBLIC_URL%" />
    <link rel="stylesheet" href="./global.css" />
    <script>
      var parcelRequire;
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.min.js" crossorigin="anonymous"></script>
    <link
      rel="shortcut icon"
      href="https://yeemachine.github.io/k2021/favicon/kalidoface3d/icon-circle.svg"
    />

    <link
      rel="apple-touch-icon"
      href="https://yeemachine.github.io/k2021/favicon/kalidoface3d/apple-icon-180.png"
    />

    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2048-2732.jpg"
      media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2732-2048.jpg"
      media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1668-2388.jpg"
      media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2388-1668.jpg"
      media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1536-2048.jpg"
      media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2048-1536.jpg"
      media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1668-2224.jpg"
      media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2224-1668.jpg"
      media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1620-2160.jpg"
      media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2160-1620.jpg"
      media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1284-2778.jpg"
      media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2778-1284.jpg"
      media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1170-2532.jpg"
      media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2532-1170.jpg"
      media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1125-2436.jpg"
      media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2436-1125.jpg"
      media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1242-2688.jpg"
      media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2688-1242.jpg"
      media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-828-1792.jpg"
      media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1792-828.jpg"
      media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1242-2208.jpg"
      media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-2208-1242.jpg"
      media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-750-1334.jpg"
      media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1334-750.jpg"
      media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-640-1136.jpg"
      media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    />
    <link
      rel="apple-touch-startup-image"
      href="https://yeemachine.github.io/k2021/splash/apple-splash-1136-640.jpg"
      media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    />
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5V3VF28');</script>
    <!-- End Google Tag Manager -->
    <script type="module" crossorigin src="./assets/index.e2bec78d.js"></script>
    <link rel="modulepreload" href="./assets/vendor.832d142e.js">
    <link rel="stylesheet" href="./assets/index.1b91a8e8.css">
    <style>
      /* Hide call/phone/peer related buttons */
      button[title*="call" i],
      button[title*="phone" i],
      button[title*="peer" i],
      button[aria-label*="call" i],
      button[aria-label*="phone" i],
      button[aria-label*="peer" i],
      .call-button,
      .phone-button,
      .peer-button,
      button:has(svg[class*="phone"]),
      button:has(svg[class*="call"]),
      button:has(svg[class*="telephone"]) {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }
      
      /* Hide information/info button and related elements */
      button[title*="info" i],
      button[title*="information" i],
      button[aria-label*="info" i],
      button[aria-label*="information" i],
      .info-button,
      .information-button,
      button.info,
      .info,
      button:has(svg[class*="info"]),
      button:has(i[class*="info"]),
      /* Hide info icon specifically */
      button:has(.info),
      /* Hide first button in utility menu (info is typically first) */
      .setting:first-child,
      .setting.info {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        width: 0 !important;
        height: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      /* Back button styles */
      .back-to-landing {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        background: rgba(102, 126, 234, 0.9);
        color: white;
        border: none;
        border-radius: 50px;
        padding: 12px 24px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        text-decoration: none;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }
      
      .back-to-landing:hover {
        background: rgba(102, 126, 234, 1);
        transform: translateX(-50%) translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        color: white;
        text-decoration: none;
      }
      
      .back-to-landing:active {
        transform: translateX(-50%) translateY(0);
      }
      
      .back-to-landing i {
        font-size: 18px;
      }
      
      /* Smartphone mode toggle button */
      .smartphone-mode-btn {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 10001;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid #667eea;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        font-size: 1.5rem;
        color: #667eea;
      }
      
      .smartphone-mode-btn:hover {
        background: #667eea;
        transform: scale(1.1);
        color: white;
      }
      
      .smartphone-mode-btn.active {
        background: #667eea;
        color: white;
      }
      
      /* Smartphone mode styles - Responsive layout */
      body.smartphone-mode {
        overflow-x: hidden;
      }
      
      /* Adjust canvas and video for mobile */
      body.smartphone-mode canvas {
        max-width: 100vw !important;
        max-height: 100vh !important;
        width: 100% !important;
        height: auto !important;
      }
      
      /* Responsive control panel for smartphone mode */
      body.smartphone-mode .control-panel-wrapper {
        bottom: 10px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        width: 95% !important;
        max-width: 100% !important;
      }
      
      body.smartphone-mode .controls-container {
        width: 100% !important;
      }
      
      body.smartphone-mode .recording-controls,
      body.smartphone-mode .playback-controls {
        flex-direction: column !important;
        gap: 8px !important;
        padding: 12px !important;
        width: 100% !important;
      }
      
      body.smartphone-mode .control-group {
        flex-direction: column !important;
        width: 100% !important;
        gap: 8px !important;
      }
      
      body.smartphone-mode .recording-controls input,
      body.smartphone-mode .playback-controls input[type="text"] {
        width: 100% !important;
        min-width: 100% !important;
        font-size: 14px !important;
        padding: 8px !important;
      }
      
      body.smartphone-mode .recording-controls button,
      body.smartphone-mode .playback-controls button {
        width: 100% !important;
        padding: 10px !important;
        font-size: 14px !important;
      }
      
      body.smartphone-mode .import-export-controls {
        flex-direction: column !important;
        width: 100% !important;
        gap: 8px !important;
      }
      
      body.smartphone-mode #importBtn,
      body.smartphone-mode #exportBtn {
        width: 100% !important;
        padding: 10px !important;
        font-size: 14px !important;
      }
      
      /* Adjust back button for smartphone mode */
      body.smartphone-mode .back-to-landing {
        top: 10px !important;
        padding: 8px 16px !important;
        font-size: 12px !important;
      }
      
      /* Adjust YCI logo for smartphone mode */
      body.smartphone-mode .yci-logo-container {
        top: 10px !important;
        right: 10px !important;
      }
      
      body.smartphone-mode .yci-logo {
        max-width: 100px !important;
        max-height: 50px !important;
      }
      
      /* Adjust smartphone mode button */
      body.smartphone-mode .smartphone-mode-btn {
        top: 10px !important;
        left: 10px !important;
        width: 45px !important;
        height: 45px !important;
        font-size: 1.2rem !important;
      }
      
      /* Adjust utility buttons position for smartphone mode */
      body.smartphone-mode section.setting,
      body.smartphone-mode .setting:not(.menu-item):not(button):not([class*="sub"]),
      body.smartphone-mode .secondaryMenu {
        right: 10px !important;
        gap: 8px !important;
      }
      
      /* Adjust preview video for smartphone mode */
      body.smartphone-mode .preview {
        bottom: 10px !important;
        right: 10px !important;
        max-width: 150px !important;
      }
      
      body.smartphone-mode .preview video {
        max-width: 150px !important;
      }
      
      @media (max-width: 768px) {
        .back-to-landing {
          top: 10px;
          padding: 10px 20px;
          font-size: 14px;
        }
        
        .control-panel-wrapper {
          width: 95% !important;
          bottom: 10px !important;
        }
        
        .recording-controls,
        .playback-controls {
          flex-direction: column !important;
          gap: 8px !important;
        }
        
        .control-group {
          flex-direction: column !important;
          width: 100% !important;
        }
        
        .recording-controls input,
        .playback-controls input[type="text"] {
          width: 100% !important;
          min-width: 100% !important;
        }
        
        .recording-controls button,
        .playback-controls button {
          width: 100% !important;
        }
        
        .import-export-controls {
          flex-direction: column !important;
          width: 100% !important;
        }
        
        #importBtn, #exportBtn {
          width: 100% !important;
        }
      }
      
      /* Extra small screens */
      @media (max-width: 480px) {
        .control-panel-wrapper {
          width: 98% !important;
          bottom: 5px !important;
        }
        
        .recording-controls,
        .playback-controls {
          padding: 10px !important;
        }
        
        .recording-controls input,
        .playback-controls input[type="text"],
        .recording-controls button,
        .playback-controls button {
          font-size: 12px !important;
          padding: 8px !important;
        }
        
        .back-to-landing {
          font-size: 12px !important;
          padding: 8px 16px !important;
        }
        
        .smartphone-mode-btn {
          width: 40px !important;
          height: 40px !important;
          font-size: 1rem !important;
        }
      }
      
      /* YCI Logo on control panel - no white frame, positioned at top right */
      .yci-logo-container {
        position: fixed;
        /* Position at top-right corner */
        top: 20px;
        right: 20px;
        left: auto;
        z-index: 9998;
        /* No background, no padding, no frame */
        background: transparent !important;
        border: none !important;
        padding: 0 !important;
        box-shadow: none !important;
        backdrop-filter: none !important;
      }
      
      .yci-logo {
        max-width: 140px;
        max-height: 70px;
        width: auto;
        height: auto;
        display: block;
        object-fit: contain;
        /* Remove any background from image */
        background: transparent !important;
        /* Ensure no border or frame */
        border: none !important;
        outline: none !important;
        /* Remove any padding or margin that might create a frame */
        padding: 0 !important;
        margin: 0 !important;
      }
      
      /* Position logo above control panel buttons on mobile */
      @media (max-width: 768px) {
        .yci-logo-container {
          top: 10px;
          right: 10px;
          left: auto;
        }
        
        .yci-logo {
          max-width: 100px;
          max-height: 50px;
        }
      }
      
      /* Move 4 utility buttons (Settings, Effects, Visibility, Share) to right side center */
      /* Target the container holding the utility buttons */
      section.setting,
      .setting:not(.menu-item):not(button):not([class*="sub"]),
      .secondaryMenu,
      [class*="setting"]:not(button):not([class*="sub"]) {
        position: fixed !important;
        right: 20px !important;
        left: auto !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
        z-index: 9997 !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        gap: 12px !important;
      }
      
      /* Control Panel Styles - same as training page */
      .control-panel-wrapper {
        position: fixed !important;
        left: 50% !important;
        bottom: 24px !important;
        transform: translateX(-50%) !important;
        width: auto !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        z-index: 10000 !important;
        pointer-events: none !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      .controls-container {
        pointer-events: auto !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      .recording-controls,
      .playback-controls {
        background: rgba(0, 0, 0, 0.5) !important;
        padding: 10px !important;
        border-radius: 5px !important;
        display: flex !important;
        justify-content: center !important;
        margin-bottom: 10px !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      .control-group {
        display: flex !important;
        gap: 10px !important;
        align-items: center !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      .recording-controls input,
      .playback-controls input[type="text"] {
        padding: 5px 10px !important;
        border: none !important;
        border-radius: 3px !important;
        background: white !important;
        min-width: 150px !important;
        color: #333 !important;
        visibility: visible !important;
        opacity: 1 !important;
        display: block !important;
      }

      .recording-controls button,
      .playback-controls button {
        padding: 5px 15px !important;
        border: none !important;
        border-radius: 3px !important;
        color: white !important;
        cursor: pointer !important;
        transition: background 0.3s !important;
        visibility: visible !important;
        opacity: 1 !important;
        display: block !important;
      }

      .recording-controls button:disabled,
      .playback-controls button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }

      #startRecord {
        background: #4CAF50;
      }

      #startRecord:hover:not(:disabled) {
        background: #45a049;
      }

      #stopRecord {
        background: #f44336;
      }

      #stopRecord:hover:not(:disabled) {
        background: #da190b;
      }

      #playbackBtn {
        background: #2196F3;
      }

      #playbackBtn:hover:not(:disabled) {
        background: #1976D2;
      }

      #stopPlaybackBtn {
        background: #FF9800;
      }

      #stopPlaybackBtn:hover:not(:disabled) {
        background: #F57C00;
      }

      .import-export-controls {
        display: flex !important;
        gap: 10px !important;
        justify-content: center !important;
        margin-top: 10px !important;
        visibility: visible !important;
        opacity: 1 !important;
      }

      #importBtn, #exportBtn {
        background: #607D8B !important;
        color: white !important;
        border: none !important;
        border-radius: 3px !important;
        padding: 5px 15px !important;
        cursor: pointer !important;
        transition: background 0.3s !important;
        visibility: visible !important;
        opacity: 1 !important;
        display: block !important;
      }

      #importBtn:hover:not(:disabled), #exportBtn:hover:not(:disabled) {
        background: #455A64;
      }

      #speechBtn {
        background: #9C27B0;
        color: white;
        border: none;
        border-radius: 3px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 18px;
        transition: background 0.3s;
      }

      #speechBtn:hover:not(:disabled) {
        background: #7B1FA2;
      }

      @media only screen and (max-width: 600px) {
        .control-panel-wrapper {
          bottom: 10px;
        }
        .recording-controls,
        .playback-controls {
          padding: 5px;
        }
        .control-group {
          flex-wrap: wrap;
          gap: 5px;
        }
        .recording-controls input,
        .playback-controls input[type="text"] {
          min-width: 100px;
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5V3VF28"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <!-- Smartphone mode toggle button -->
    <button class="smartphone-mode-btn" id="smartphoneModeBtn" title="Toggle Smartphone Mode">üì±</button>
    <!-- Back to Landing Page Button -->
    <a href="../index.html" class="back-to-landing" title="Back to Talk2Sign Home">
      <i>‚Üê</i>
      <span>Back to Home</span>
    </a>
    
    <!-- YCI Logo on Control Panel -->
    <div class="yci-logo-container">
      <img src="./yci_logo.jpg" alt="YCI Logo" class="yci-logo">
    </div>
    
    <!-- Control Panel for Recording/Playback -->
    <div class="control-panel-wrapper">
      <div class="controls-container">
        <div class="recording-controls">
          <div class="control-group">
            <input type="text" id="signName" placeholder="Enter sign name" />
            <button id="startRecord">Start Record</button>
            <button id="stopRecord" disabled>Stop Record</button>
          </div>
        </div>
        <div class="playback-controls">
          <div class="control-group">
            <input type="text" id="signNamePlayback" placeholder="Enter or recognize sign names, separated by spaces" />
            <button id="speechBtn">üé§</button>
            <button id="playbackBtn">Playback</button>
            <button id="stopPlaybackBtn" disabled>Stop Playback</button>
          </div>
        </div>
        <div class="import-export-controls">
          <button id="exportBtn">Export</button>
          <input type="file" id="importInput" accept="application/json" style="display:none;" />
          <button id="importBtn">Import</button>
        </div>
      </div>
    </div>
    
    <h1 class="notranslate">kalidoface</h1>
    
    <!--     <pwa-update></pwa-update> -->
    <script>
      // Remove call/phone/peer buttons after page loads
      (function() {
        function hideCallButtons() {
          // Find all buttons
          const buttons = document.querySelectorAll('button');
          buttons.forEach(button => {
            const text = button.textContent || button.innerText || '';
            const title = button.getAttribute('title') || '';
            const ariaLabel = button.getAttribute('aria-label') || '';
            const className = button.className || '';
            
            // Check if button is related to call/phone/peer
            const isCallButton = 
              /call|phone|telephone|peer/i.test(text) ||
              /call|phone|telephone|peer/i.test(title) ||
              /call|phone|telephone|peer/i.test(ariaLabel) ||
              /call|phone|telephone|peer/i.test(className);
            
            if (isCallButton) {
              button.style.display = 'none';
              button.style.visibility = 'hidden';
              button.style.opacity = '0';
              button.style.pointerEvents = 'none';
              button.remove();
            }
          });
          
          // Also check for SVG icons related to phone/call
          const svgs = document.querySelectorAll('svg');
          svgs.forEach(svg => {
            const parent = svg.closest('button');
            if (parent) {
              const svgText = svg.innerHTML || '';
              if (/phone|call|telephone/i.test(svgText) || 
                  svg.querySelector('path[d*="M20"]') || // Common phone icon path
                  svg.querySelector('path[d*="phone"]')) {
                parent.style.display = 'none';
                parent.remove();
              }
            }
          });
        }
        
        // Run immediately
        hideCallButtons();
        
        // Run after DOM is fully loaded
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', hideCallButtons);
        } else {
          hideCallButtons();
        }
        
        // Run after a delay to catch dynamically loaded buttons
        setTimeout(hideCallButtons, 1000);
        setTimeout(hideCallButtons, 3000);
      })();
      
      // Remove information button and related functionality
      (function() {
        function hideInfoButton() {
          // Find all buttons and check for info-related content
          const buttons = document.querySelectorAll('button');
          buttons.forEach(button => {
            const text = button.textContent || button.innerText || '';
            const title = button.getAttribute('title') || '';
            const ariaLabel = button.getAttribute('aria-label') || '';
            const className = button.className || '';
            const id = button.id || '';
            
            // Check if button is related to information
            const isInfoButton = 
              /info|information/i.test(text) ||
              /info|information/i.test(title) ||
              /info|information/i.test(ariaLabel) ||
              /info|information/i.test(className) ||
              /info|information/i.test(id) ||
              button.querySelector('i[class*="info"]') ||
              button.querySelector('svg[class*="info"]') ||
              button.querySelector('.info');
            
            if (isInfoButton) {
              button.style.display = 'none';
              button.style.visibility = 'hidden';
              button.style.opacity = '0';
              button.style.pointerEvents = 'none';
              button.style.width = '0';
              button.style.height = '0';
              button.style.margin = '0';
              button.style.padding = '0';
              button.remove();
            }
          });
          
          // Remove info-related elements
          const infoElements = document.querySelectorAll('.info, [class*="info"], [id*="info"]');
          infoElements.forEach(el => {
            // Only remove if it's a button or button-related
            if (el.tagName === 'BUTTON' || el.closest('button') || el.classList.contains('info')) {
              el.style.display = 'none';
              el.style.visibility = 'hidden';
              el.remove();
            }
          });
          
          // Remove first button in utility menu (if info is first)
          const settingButtons = document.querySelectorAll('.setting, [class*="setting"]');
          if (settingButtons.length > 0) {
            const firstButton = settingButtons[0];
            // Check if it's an info button
            if (firstButton.querySelector('.info') || 
                /info/i.test(firstButton.className) ||
                /info/i.test(firstButton.getAttribute('title') || '')) {
              firstButton.style.display = 'none';
              firstButton.remove();
            }
          }
        }
        
        // Run immediately
        hideInfoButton();
        
        // Run after DOM is fully loaded
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', hideInfoButton);
        } else {
          hideInfoButton();
        }
        
        // Run after delays to catch dynamically loaded buttons
        setTimeout(hideInfoButton, 500);
        setTimeout(hideInfoButton, 1000);
        setTimeout(hideInfoButton, 2000);
        setTimeout(hideInfoButton, 3000);
      })();
      
      // Move 4 utility buttons (Settings, Effects, Visibility, Share) to right side center
      (function() {
        function moveUtilityButtons() {
          // Find the container that holds the 4 utility buttons
          const settingElements = document.querySelectorAll('.setting, [class*="setting"], .secondaryMenu, [class*="secondaryMenu"]');
          const menuElements = document.querySelectorAll('nav[class*="menu"], section[class*="setting"]');
          
          // Combine all potential containers
          const allElements = [...settingElements, ...menuElements];
          
          allElements.forEach(element => {
            // Check if it contains utility buttons (Settings, Effects, Visibility, Share)
            const buttons = element.querySelectorAll('button, .subButton, .menu-item');
            if (buttons.length >= 3 && buttons.length <= 5) {
              // Check if buttons are utility buttons (not info, call, etc.)
              const utilityButtonCount = Array.from(buttons).filter(btn => {
                const title = (btn.getAttribute('title') || '').toLowerCase();
                const ariaLabel = (btn.getAttribute('aria-label') || '').toLowerCase();
                const className = (btn.className || '').toLowerCase();
                return /setting|gear|effect|magic|wand|visibility|eye|share|export|duplicate/i.test(title + ariaLabel + className) &&
                       !/info|information|call|phone|peer/i.test(title + ariaLabel + className);
              }).length;
              
              // If it has 3-4 utility buttons, move the container
              if (utilityButtonCount >= 3) {
                element.style.position = 'fixed';
                element.style.right = '20px';
                element.style.left = 'auto';
                element.style.top = '50%';
                element.style.transform = 'translateY(-50%)';
                element.style.zIndex = '9997';
                element.style.display = 'flex';
                element.style.flexDirection = 'column';
                element.style.alignItems = 'center';
                element.style.gap = '12px';
              }
            }
          });
          
          // Alternative: Find buttons directly and group them
          const allButtons = document.querySelectorAll('button');
          const utilityButtons = Array.from(allButtons).filter(btn => {
            const title = (btn.getAttribute('title') || '').toLowerCase();
            const ariaLabel = (btn.getAttribute('aria-label') || '').toLowerCase();
            const className = (btn.className || '').toLowerCase();
            // Look for settings, effects, visibility, share buttons
            return /setting|gear|effect|magic|wand|visibility|eye|share|export|duplicate/i.test(title + ariaLabel + className) &&
                   !/info|information|call|phone|peer/i.test(title + ariaLabel + className);
          });
          
          // If we found 3-4 utility buttons, ensure they're positioned correctly
          if (utilityButtons.length >= 3 && utilityButtons.length <= 4) {
            // Check if they have a common parent
            const parents = utilityButtons.map(btn => btn.parentElement);
            const commonParent = parents[0];
            
            // If all buttons share the same parent and it's not already positioned
            if (commonParent && parents.every(p => p === commonParent)) {
              const computedStyle = window.getComputedStyle(commonParent);
              if (computedStyle.position !== 'fixed' || !computedStyle.top.includes('50%')) {
                commonParent.style.position = 'fixed';
                commonParent.style.right = '20px';
                commonParent.style.left = 'auto';
                commonParent.style.top = '50%';
                commonParent.style.transform = 'translateY(-50%)';
                commonParent.style.zIndex = '9997';
                commonParent.style.display = 'flex';
                commonParent.style.flexDirection = 'column';
                commonParent.style.alignItems = 'center';
                commonParent.style.gap = '12px';
              }
            }
          }
        }
        
        // Run immediately
        moveUtilityButtons();
        
        // Run after DOM is fully loaded
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', moveUtilityButtons);
        } else {
          moveUtilityButtons();
        }
        
        // Run after delays to catch dynamically loaded elements
        setTimeout(moveUtilityButtons, 500);
        setTimeout(moveUtilityButtons, 1000);
        setTimeout(moveUtilityButtons, 2000);
        setTimeout(moveUtilityButtons, 3000);
        
        // Use MutationObserver to watch for dynamically added elements
        const observer = new MutationObserver(() => {
          moveUtilityButtons();
        });
        
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
      })();
      
      // Auto-load default VRM character
      (function() {
        const DEFAULT_VRM = './2608284133256745833.vrm';
        let loadAttempted = false;
        
        function loadDefaultVRM() {
          if (loadAttempted) return;
          
          // Wait for the app to be fully loaded
          if (typeof window === 'undefined') return;
          
          // Try multiple methods to load the VRM file
          function attemptLoad() {
            // Method 1: Look for file input and trigger file selection
            const fileInputs = document.querySelectorAll('input[type="file"][accept*="vrm"], input[type="file"][accept*=".vrm"], input[type="file"][id*="upload"], input[type="file"][name*="file"]');
            if (fileInputs.length > 0) {
              const fileInput = fileInputs[0];
              
              // Fetch the VRM file and create a File object
              fetch(DEFAULT_VRM)
                .then(response => {
                  if (!response.ok) throw new Error('Failed to fetch VRM file');
                  return response.blob();
                })
                .then(blob => {
                  const file = new File([blob], '2608284133256745833.vrm', { type: 'application/octet-stream' });
                  const dataTransfer = new DataTransfer();
                  dataTransfer.items.add(file);
                  fileInput.files = dataTransfer.files;
                  
                  // Trigger change event
                  const changeEvent = new Event('change', { bubbles: true, cancelable: true });
                  fileInput.dispatchEvent(changeEvent);
                  
                  // Also try input event
                  const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                  fileInput.dispatchEvent(inputEvent);
                  
                  loadAttempted = true;
                  console.log('‚úÖ Default VRM character loaded:', DEFAULT_VRM);
                })
                .catch(err => {
                  console.warn('‚ö†Ô∏è Could not auto-load VRM file via file input:', err);
                });
              return true;
            }
            
            // Method 2: Look for drop zone and simulate file drop
            const dropZones = document.querySelectorAll('[class*="drop"], [data-drop], [class*="upload"], [class*="drop_zone"]');
            if (dropZones.length > 0) {
              fetch(DEFAULT_VRM)
                .then(response => {
                  if (!response.ok) throw new Error('Failed to fetch VRM file');
                  return response.blob();
                })
                .then(blob => {
                  const file = new File([blob], '2608284133256745833.vrm', { type: 'application/octet-stream' });
                  const dropZone = dropZones[0];
                  
                  // Create DataTransfer for drag and drop
                  const dataTransfer = new DataTransfer();
                  dataTransfer.items.add(file);
                  
                  // Create drop event
                  const dropEvent = new DragEvent('drop', {
                    bubbles: true,
                    cancelable: true,
                    dataTransfer: dataTransfer
                  });
                  
                  // Also trigger dragover first (required for some apps)
                  const dragOverEvent = new DragEvent('dragover', {
                    bubbles: true,
                    cancelable: true,
                    dataTransfer: dataTransfer
                  });
                  dropZone.dispatchEvent(dragOverEvent);
                  dropZone.dispatchEvent(dropEvent);
                  
                  loadAttempted = true;
                  console.log('‚úÖ Default VRM character loaded via drop zone:', DEFAULT_VRM);
                })
                .catch(err => {
                  console.warn('‚ö†Ô∏è Could not auto-load VRM file via drop zone:', err);
                });
              return true;
            }
            
            return false;
          }
          
          // Try loading
          if (attemptLoad()) {
            loadAttempted = true;
          }
        }
        
        // Wait for page to load and app to initialize
        function initLoad() {
          // Try multiple times with increasing delays
          const delays = [1000, 2000, 3000, 5000];
          delays.forEach(delay => {
            setTimeout(() => {
              if (!loadAttempted) {
                loadDefaultVRM();
              }
            }, delay);
          });
        }
        
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initLoad);
        } else {
          initLoad();
        }
        
        // Also listen for any custom events that might indicate app is ready
        window.addEventListener('load', () => {
          setTimeout(loadDefaultVRM, 3000);
        });
      })();
      
      // Force control panel to be visible
      (function() {
        function ensurePanelVisible() {
          const panel = document.querySelector('.control-panel-wrapper');
          if (panel) {
            panel.style.display = 'flex';
            panel.style.visibility = 'visible';
            panel.style.opacity = '1';
            panel.style.zIndex = '10000';
            panel.style.position = 'fixed';
            panel.style.left = '50%';
            panel.style.bottom = '24px';
            panel.style.transform = 'translateX(-50%)';
            console.log('‚úÖ Control panel forced to be visible');
          } else {
            console.log('Control panel not found yet');
          }
        }
        
        // Run immediately
        ensurePanelVisible();
        
        // Run after DOM loads
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', ensurePanelVisible);
        }
        
        // Run after page fully loads
        window.addEventListener('load', () => {
          setTimeout(ensurePanelVisible, 1000);
          setTimeout(ensurePanelVisible, 2000);
          setTimeout(ensurePanelVisible, 3000);
        });
        
        // Use MutationObserver to ensure it stays visible
        const observer = new MutationObserver(() => {
          ensurePanelVisible();
        });
        observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class'] });
      })();
      
      // Add recording/playback functionality - hook into existing MediaPipe results
      (function() {
        // IndexedDB setup
        const dbName = "signLanguageDB";
        const storeName = "signRecordings";
        let db;
        
        // Recording state
        let isRecording = false;
        let recordedData = [];
        let recordingStartTime;
        let isPlaybackActive = false;
        let playbackData = null;
        let playbackFrameIndex = 0;
        let playbackInterval = null;
        let originalHolisticCallback = null;
        let holisticInstance = null;
        let mediaPipeResultsHandler = null;
        let cameraInstance = null; // Store camera instance for stopping/starting
        let drawResultsFunction = null; // Store drawResults function
        let animateVRMFunction = null; // Store animateVRM function
        
        // Hook into MediaPipe results by intercepting the Holistic instance
        function hookIntoMediaPipeResults() {
          // Method 1: Try to find existing holistic instance in window
          if (window.holistic) {
            holisticInstance = window.holistic;
            if (holisticInstance.onResults) {
              originalHolisticCallback = holisticInstance.onResults;
              holisticInstance.onResults = function(results) {
                if (originalHolisticCallback) {
                  originalHolisticCallback(results);
                }
                handleMediaPipeResults(results);
              };
              console.log('‚úÖ Hooked into MediaPipe results (window.holistic)');
              return true;
            }
          }
          
          // Method 2: Intercept Holistic constructor
          if (window.Holistic) {
            const OriginalHolistic = window.Holistic;
            window.Holistic = function(options) {
              const instance = new OriginalHolistic(options);
              if (instance.onResults) {
                originalHolisticCallback = instance.onResults;
                instance.onResults = function(results) {
                  if (originalHolisticCallback) {
                    originalHolisticCallback(results);
                  }
                  handleMediaPipeResults(results);
                };
              }
              holisticInstance = instance;
              console.log('‚úÖ Intercepted Holistic instance');
              return instance;
            };
            // Copy static properties
            Object.setPrototypeOf(window.Holistic, OriginalHolistic);
            Object.assign(window.Holistic, OriginalHolistic);
          }
          
          // Method 3: Use MutationObserver to find holistic instance after app loads
          const observer = new MutationObserver(() => {
            // Look for holistic in various places
            if (window.holistic && !holisticInstance) {
              holisticInstance = window.holistic;
              if (holisticInstance.onResults) {
                originalHolisticCallback = holisticInstance.onResults;
                holisticInstance.onResults = function(results) {
                  if (originalHolisticCallback) {
                    originalHolisticCallback(results);
                  }
                  handleMediaPipeResults(results);
                };
                console.log('‚úÖ Hooked into MediaPipe results (MutationObserver)');
                findCameraAndFunctions(); // Also find camera and functions
                observer.disconnect();
              }
            }
            
            // Also look for camera instance
            if (window.Camera && !cameraInstance) {
              const videoElement = document.querySelector('video.input_video');
              if (videoElement && videoElement._camera) {
                cameraInstance = videoElement._camera;
                console.log('‚úÖ Found camera instance');
              }
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
          
          // Also try after delays
          setTimeout(() => {
            if (window.holistic && !holisticInstance) {
              holisticInstance = window.holistic;
              if (holisticInstance && holisticInstance.onResults) {
                originalHolisticCallback = holisticInstance.onResults;
                holisticInstance.onResults = function(results) {
                  if (originalHolisticCallback) {
                    originalHolisticCallback(results);
                  }
                  handleMediaPipeResults(results);
                };
                console.log('‚úÖ Hooked into MediaPipe results (delayed)');
              }
            }
            findCameraAndFunctions(); // Also find camera and functions
          }, 3000);
          
          // Try to find camera by intercepting Camera constructor
          if (window.Camera) {
            const OriginalCamera = window.Camera;
            window.Camera = function(videoElement, options) {
              const instance = new OriginalCamera(videoElement, options);
              cameraInstance = instance;
              if (videoElement) {
                videoElement._camera = instance; // Store reference
              }
              console.log('‚úÖ Intercepted Camera instance');
              return instance;
            };
            // Copy static properties
            Object.setPrototypeOf(window.Camera, OriginalCamera);
            Object.assign(window.Camera, OriginalCamera);
          }
        }
        
        // Handle MediaPipe results for recording/playback
        function handleMediaPipeResults(results) {
          // Record landmarks if recording is active
          if (isRecording && results) {
            const timestamp = Date.now() - recordingStartTime;
            recordedData.push({
              timestamp,
              faceLandmarks: results.faceLandmarks,
              poseLandmarks: results.poseLandmarks,
              pose3DLandmarks: results.ea,
              leftHandLandmarks: results.leftHandLandmarks,
              rightHandLandmarks: results.rightHandLandmarks
            });
          }
        }
        
        // Initialize IndexedDB
        const initDB = () => {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, 2);
            
            request.onerror = (event) => {
              console.error("Error opening database:", event.target.error);
              reject(event.target.error);
            };
            
            request.onsuccess = (event) => {
              db = event.target.result;
              console.log("Database opened successfully");
              resolve(db);
            };
            
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName, { keyPath: "id", autoIncrement: true });
              }
            };
          });
        };
        
        // Save recording to IndexedDB
        const saveRecording = async (signName, data) => {
          return new Promise((resolve, reject) => {
            if (!db) {
              reject(new Error("Database not initialized"));
              return;
            }
            const transaction = db.transaction([storeName], "readwrite");
            const store = transaction.objectStore(storeName);
            
            const recording = {
              signName,
              data,
              timestamp: new Date().toISOString()
            };
            
            const request = store.add(recording);
            
            request.onsuccess = () => {
              console.log("Recording saved successfully");
              resolve();
            };
            
            request.onerror = (event) => {
              console.error("Error saving recording:", event.target.error);
              reject(event.target.error);
            };
          });
        };
        
        // Initialize recording controls
        const initRecordingControls = () => {
          const startButton = document.getElementById("startRecord");
          const stopButton = document.getElementById("stopRecord");
          const signNameInput = document.getElementById("signName");
          
          if (!startButton || !stopButton || !signNameInput) {
            console.error("Recording controls not found, retrying...");
            setTimeout(initRecordingControls, 500);
            return;
          }
          
          startButton.addEventListener("click", () => {
            if (!signNameInput.value.trim()) {
              alert("Please enter a sign name");
              return;
            }
            isRecording = true;
            recordedData = [];
            recordingStartTime = Date.now();
            startButton.disabled = true;
            stopButton.disabled = false;
            signNameInput.disabled = true;
            console.log("Recording started");
          });
          
          stopButton.addEventListener("click", async () => {
            isRecording = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            signNameInput.disabled = false;
            
            try {
              if (!db) {
                await initDB();
              }
              if (recordedData.length === 0) {
                alert("No data recorded. Please try again.");
                return;
              }
              await saveRecording(signNameInput.value.trim(), recordedData);
              alert("Recording saved successfully!");
            } catch (error) {
              console.error("Error saving recording:", error);
              alert("Error saving recording: " + error.message);
            }
          });
        };
        
        // Find and store camera instance, drawResults, and animateVRM functions
        function findCameraAndFunctions() {
          // Try to find camera instance
          if (window.Camera && !cameraInstance) {
            // Look for existing camera instances
            const videoElement = document.querySelector('video.input_video');
            if (videoElement) {
              // Try to find camera in various ways
              if (window.camera) {
                cameraInstance = window.camera;
              }
            }
          }
          
          // Try to find drawResults function
          if (window.drawResults && !drawResultsFunction) {
            drawResultsFunction = window.drawResults;
          }
          
          // Try to find animateVRM function
          if (window.animateVRM && !animateVRMFunction) {
            animateVRMFunction = window.animateVRM;
          }
          
          // Also try to find currentVrm
          if (window.currentVrm && !animateVRMFunction) {
            // We'll use window.currentVrm directly
          }
        }
        
        // Create drawResults function if not available
        function createDrawResultsFunction() {
          if (drawResultsFunction) return drawResultsFunction;
          
          const videoElement = document.querySelector('video.input_video');
          const guideCanvas = document.querySelector('canvas.guides');
          
          if (!videoElement || !guideCanvas) return null;
          
          return function(results) {
            if (!guideCanvas || !videoElement) return;
            guideCanvas.width = videoElement.videoWidth || 640;
            guideCanvas.height = videoElement.videoHeight || 480;
            let canvasCtx = guideCanvas.getContext("2d");
            if (!canvasCtx) return;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            
            // Draw pose landmarks
            if (results.poseLandmarks && results.poseLandmarks.length > 0 && window.POSE_CONNECTIONS) {
              if (window.drawConnectors) {
                window.drawConnectors(canvasCtx, results.poseLandmarks, window.POSE_CONNECTIONS, {
                  color: "#00cff7",
                  lineWidth: 4,
                });
              }
              if (window.drawLandmarks) {
                window.drawLandmarks(canvasCtx, results.poseLandmarks, {
                  color: "#ff0364",
                  lineWidth: 2,
                });
              }
            }
            
            // Draw face landmarks
            if (results.faceLandmarks && results.faceLandmarks.length > 0 && window.FACEMESH_TESSELATION) {
              if (window.drawConnectors) {
                window.drawConnectors(canvasCtx, results.faceLandmarks, window.FACEMESH_TESSELATION, {
                  color: "#C0C0C070",
                  lineWidth: 1,
                });
              }
              if (results.faceLandmarks.length === 478 && window.drawLandmarks) {
                window.drawLandmarks(canvasCtx, [results.faceLandmarks[468], results.faceLandmarks[468 + 5]], {
                  color: "#ffe603",
                  lineWidth: 2,
                });
              }
            }
            
            // Draw hand landmarks
            if (results.leftHandLandmarks && results.leftHandLandmarks.length > 0 && window.HAND_CONNECTIONS) {
              if (window.drawConnectors) {
                window.drawConnectors(canvasCtx, results.leftHandLandmarks, window.HAND_CONNECTIONS, {
                  color: "#eb1064",
                  lineWidth: 5,
                });
              }
              if (window.drawLandmarks) {
                window.drawLandmarks(canvasCtx, results.leftHandLandmarks, {
                  color: "#00cff7",
                  lineWidth: 2,
                });
              }
            }
            
            if (results.rightHandLandmarks && results.rightHandLandmarks.length > 0 && window.HAND_CONNECTIONS) {
              if (window.drawConnectors) {
                window.drawConnectors(canvasCtx, results.rightHandLandmarks, window.HAND_CONNECTIONS, {
                  color: "#22c3e3",
                  lineWidth: 5,
                });
              }
              if (window.drawLandmarks) {
                window.drawLandmarks(canvasCtx, results.rightHandLandmarks, {
                  color: "#ff0364",
                  lineWidth: 2,
                });
              }
            }
            
            canvasCtx.restore();
          };
        }
        
        // Stop playback and resume real-time tracking
        const stopPlayback = () => {
          if (!isPlaybackActive) return;
          isPlaybackActive = false;
          playbackData = null;
          playbackFrameIndex = 0;
          if (playbackInterval) {
            clearInterval(playbackInterval);
            playbackInterval = null;
          }
          
          // Restore original onResults callback
          if (holisticInstance && originalHolisticCallback) {
            holisticInstance.onResults = originalHolisticCallback;
          }
          
          // Restart camera if we have the instance
          if (cameraInstance && typeof cameraInstance.start === 'function') {
            try {
              cameraInstance.start();
            } catch (e) {
              console.log('Could not restart camera:', e);
            }
          }
          
          // Re-enable controls
          const startRecordBtn = document.getElementById("startRecord");
          const stopRecordBtn = document.getElementById("stopRecord");
          const signNameInput = document.getElementById("signName");
          const signNamePlaybackInput = document.getElementById("signNamePlayback");
          const speechBtn = document.getElementById("speechBtn");
          const playbackBtn = document.getElementById("playbackBtn");
          const stopPlaybackBtn = document.getElementById("stopPlaybackBtn");
          
          if (startRecordBtn) startRecordBtn.disabled = false;
          if (stopRecordBtn) stopRecordBtn.disabled = true;
          if (signNameInput) signNameInput.disabled = false;
          if (signNamePlaybackInput) signNamePlaybackInput.disabled = false;
          if (speechBtn) speechBtn.disabled = false;
          if (playbackBtn) playbackBtn.disabled = false;
          if (stopPlaybackBtn) stopPlaybackBtn.disabled = true;
          
          console.log('‚úÖ Playback stopped, real-time tracking resumed');
        };
        
        // Start playback
        const startPlaybackByNames = async (signNames) => {
          if (isPlaybackActive) return;
          if (!signNames.length) {
            alert("Please enter or recognize at least one sign name to play");
            return;
          }
          if (!db) {
            await initDB();
          }
          const transaction = db.transaction([storeName], "readonly");
          const store = transaction.objectStore(storeName);
          const request = store.getAll();
          request.onsuccess = () => {
            const recordings = request.result;
            const queue = [];
            const notFound = [];
            const foundNames = new Set(); // Track found names to avoid duplicates
            
            signNames.forEach(name => {
              const trimmedName = name.trim();
              if (!trimmedName || foundNames.has(trimmedName.toLowerCase())) {
                return; // Skip empty or already found names
              }
              
              const rec = recordings.find(r => {
                if (!r.signName) return false;
                // Exact match (case-insensitive)
                return r.signName.toLowerCase() === trimmedName.toLowerCase();
              });
              
              if (rec) {
                queue.push(rec);
                foundNames.add(trimmedName.toLowerCase());
              } else {
                notFound.push(trimmedName);
              }
            });
            
            if (!queue.length) {
              alert("No matching recordings found for the given sign names.");
              return;
            }
            let currentIdx = 0;
            const playNext = () => {
              if (currentIdx >= queue.length) {
                stopPlayback();
                if (notFound.length) {
                  alert("Some sign(s) not found: " + notFound.join(", "));
                }
                return;
              }
              const recording = queue[currentIdx];
              if (!recording || !recording.data || !Array.isArray(recording.data) || recording.data.length === 0) {
                currentIdx++;
                playNext();
                return;
              }
              isPlaybackActive = true;
              playbackData = recording.data;
              playbackFrameIndex = 0;
              
              // Find camera and functions before starting playback
              findCameraAndFunctions();
              const drawResults = drawResultsFunction || createDrawResultsFunction();
              
              // Disable controls
              const startRecordBtn = document.getElementById("startRecord");
              const stopRecordBtn = document.getElementById("stopRecord");
              const signNameInput = document.getElementById("signName");
              const signNamePlaybackInput = document.getElementById("signNamePlayback");
              const speechBtn = document.getElementById("speechBtn");
              const playbackBtn = document.getElementById("playbackBtn");
              const stopPlaybackBtn = document.getElementById("stopPlaybackBtn");
              
              if (startRecordBtn) startRecordBtn.disabled = true;
              if (stopRecordBtn) stopRecordBtn.disabled = true;
              if (signNameInput) signNameInput.disabled = true;
              if (signNamePlaybackInput) signNamePlaybackInput.disabled = true;
              if (speechBtn) speechBtn.disabled = true;
              if (playbackBtn) playbackBtn.disabled = true;
              if (stopPlaybackBtn) stopPlaybackBtn.disabled = false;
              
              // Stop camera to pause real-time tracking
              if (cameraInstance && typeof cameraInstance.stop === 'function') {
                try {
                  cameraInstance.stop();
                  console.log('‚úÖ Camera stopped for playback');
                } catch (e) {
                  console.log('Could not stop camera:', e);
                }
              }
              
              // Override holistic.onResults to prevent real-time tracking during playback
              if (holisticInstance && originalHolisticCallback) {
                holisticInstance.onResults = function(results) {
                  // Do nothing - we're in playback mode
                };
              }
              
              if (playbackInterval) clearInterval(playbackInterval);
              playbackInterval = setInterval(() => {
                if (!isPlaybackActive || !playbackData || playbackFrameIndex >= playbackData.length) {
                  clearInterval(playbackInterval);
                  playbackInterval = null;
                  currentIdx++;
                  playNext();
                  return;
                }
                
                const currentFrame = playbackData[playbackFrameIndex];
                if (!currentFrame) {
                  playbackFrameIndex++;
                  return;
                }
                
                // Create results object for playback
                const playbackResults = {
                  faceLandmarks: currentFrame.faceLandmarks || null,
                  poseLandmarks: currentFrame.poseLandmarks || null,
                  ea: currentFrame.pose3DLandmarks || null,
                  leftHandLandmarks: currentFrame.leftHandLandmarks || null,
                  rightHandLandmarks: currentFrame.rightHandLandmarks || null
                };
                
                // Draw skeleton on video preview (top left corner)
                if (drawResults) {
                  drawResults(playbackResults);
                }
                
                // Animate 3D avatar using Kalidoface's animation function
                if (originalHolisticCallback) {
                  originalHolisticCallback(playbackResults);
                }
                
                playbackFrameIndex++;
              }, 33); // ~30 FPS
            };
            playNext();
          };
        };
        
        // Initialize playback controls
        const initPlaybackControls = () => {
          const playbackBtn = document.getElementById("playbackBtn");
          const stopPlaybackBtn = document.getElementById("stopPlaybackBtn");
          const signNamePlayback = document.getElementById("signNamePlayback");
          const speechBtn = document.getElementById("speechBtn");
          
          if (!playbackBtn || !stopPlaybackBtn || !signNamePlayback) {
            console.error("Playback controls not found, retrying...");
            setTimeout(initPlaybackControls, 500);
            return;
          }
          
          playbackBtn.addEventListener("click", async () => {
            const inputValue = signNamePlayback.value.trim();
            if (!inputValue) {
              alert("Please enter a sign name to play");
              return;
            }
            
            // Get all recordings from database first to check for phrases
            if (!db) {
              await initDB();
            }
            const transaction = db.transaction([storeName], "readonly");
            const store = transaction.objectStore(storeName);
            const getAllRequest = store.getAll();
            
            getAllRequest.onsuccess = () => {
              const allRecordings = getAllRequest.result;
              const allSignNames = allRecordings.map(r => r.signName ? r.signName.toLowerCase() : '').filter(Boolean);
              
              // Smart parsing: try to match phrases first, then individual words
              let names = [];
              
              if (inputValue.includes(' ')) {
                // Input has spaces - try to match phrases intelligently
                const words = inputValue.split(/\s+/).map(s => s.trim()).filter(Boolean);
                
                // First, try exact match
                if (allSignNames.includes(inputValue.toLowerCase())) {
                  names.push(inputValue);
                } else {
                  // Greedy matching: try to find longest phrases first
                  let i = 0;
                  while (i < words.length) {
                    let found = false;
                    // Try phrases of decreasing length (longest first) starting from current position
                    for (let len = Math.min(words.length - i, 5); len >= 1; len--) {
                      const phrase = words.slice(i, i + len).join(' ');
                      if (allSignNames.includes(phrase.toLowerCase())) {
                        names.push(phrase);
                        i += len; // Skip the words we just matched
                        found = true;
                        break;
                      }
                    }
                    if (!found) {
                      // No phrase found starting at this position, try single word
                      if (allSignNames.includes(words[i].toLowerCase())) {
                        names.push(words[i]);
                      }
                      i++;
                    }
                  }
                }
              } else {
                // Single word
                names = [inputValue];
              }
              
              if (names.length === 0) {
                alert("No matching recordings found for: " + inputValue);
                return;
              }
              
              startPlaybackByNames(names);
            };
          });
          stopPlaybackBtn.addEventListener("click", stopPlayback);
          
          // Speech recognition
          let recognition = null;
          if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'zh-HK'; // Cantonese (Hong Kong)
            
            recognition.onresult = (event) => {
              const transcript = event.results[0][0].transcript;
              // Remove full stop (period) and comma from transcript
              signNamePlayback.value = transcript.trim().replace(/[.,]/g, '');
            };
            
            recognition.onerror = (event) => {
              console.error("Speech recognition error:", event.error);
              alert("Speech recognition error: " + event.error);
            };
          }
          
          speechBtn.addEventListener("click", () => {
            if (recognition) {
              try {
                recognition.start();
                speechBtn.textContent = "üé§...";
                speechBtn.disabled = true;
                recognition.onend = () => {
                  speechBtn.textContent = "üé§";
                  speechBtn.disabled = false;
                };
              } catch (error) {
                console.error("Error starting speech recognition:", error);
                alert("Speech recognition not available. Please enter sign names manually.");
              }
            } else {
              alert("Speech recognition not supported in this browser. Please enter sign names manually.");
            }
          });
        };
        
        // Export recordings
        const exportRecordings = () => {
          if (!db) {
            alert("Database not initialized");
            return;
          }
          const transaction = db.transaction([storeName], "readonly");
          const store = transaction.objectStore(storeName);
          const request = store.getAll();
          request.onsuccess = () => {
            const data = request.result;
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "sign_recordings.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          };
        };
        
        // Import recordings
        const importRecordings = (file) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const importedData = JSON.parse(event.target.result);
              if (!Array.isArray(importedData)) {
                alert("Invalid file format.");
                return;
              }
              if (!db) {
                alert("Database not initialized");
                return;
              }
              const transaction = db.transaction([storeName], "readwrite");
              const store = transaction.objectStore(storeName);
              let importedCount = 0;
              let processed = 0;
              importedData.forEach((recording) => {
                store.add(recording);
                importedCount++;
                processed++;
                if (processed === importedData.length) {
                  alert(`Imported ${importedCount} new recordings.`);
                }
              });
            } catch (e) {
              alert("Failed to import: " + e.message);
            }
          };
          reader.readAsText(file);
        };
        
        // Initialize import/export controls
        const initImportExportControls = () => {
          const exportBtn = document.getElementById("exportBtn");
          const importBtn = document.getElementById("importBtn");
          const importInput = document.getElementById("importInput");
          
          if (!exportBtn || !importBtn || !importInput) {
            console.error("Import/export controls not found, retrying...");
            setTimeout(initImportExportControls, 500);
            return;
          }
          
          exportBtn.addEventListener("click", exportRecordings);
          importBtn.addEventListener("click", () => importInput.click());
          importInput.addEventListener("change", (e) => {
            if (importInput.files && importInput.files[0]) {
              importRecordings(importInput.files[0]);
              importInput.value = "";
            }
          });
        };
        
        // Initialize everything
        (async () => {
          try {
            await initDB();
            hookIntoMediaPipeResults();
            // Initialize controls with retries
            const initControls = async () => {
              initRecordingControls();
              initPlaybackControls();
              initImportExportControls();
              // Wait for database to be ready, then auto-import default model if selected
              if (!db) {
                await initDB();
              }
              // Wait a bit longer to ensure database is fully ready
              setTimeout(() => {
                autoImportDefaultModel().catch(err => {
                  console.error("Auto-import error:", err);
                  // Retry after a delay
                  setTimeout(() => autoImportDefaultModel(), 1000);
                });
              }, 1000);
            };
            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initControls, 1000);
              });
            } else {
              setTimeout(initControls, 1000);
            }
            console.log("‚úÖ Recording panel initialized");
            
            // Clear database function
            async function clearDatabase() {
              return new Promise((resolve, reject) => {
                if (!db) {
                  reject(new Error("Database not initialized"));
                  return;
                }
                const transaction = db.transaction([storeName], "readwrite");
                const store = transaction.objectStore(storeName);
                const clearRequest = store.clear();
                clearRequest.onsuccess = () => {
                  console.log("‚úÖ Database cleared");
                  resolve();
                };
                clearRequest.onerror = () => {
                  console.error("Error clearing database");
                  reject(clearRequest.error);
                };
              });
            }
            
            // Auto-import default model function - uses same approach as manual import
            async function autoImportDefaultModel() {
              try {
                const selectedModel = localStorage.getItem('selectedModel') || 'default';
                const modelProcessed = localStorage.getItem('modelProcessed');
                
                // Check if we need to process the model
                if (!modelProcessed || modelProcessed !== selectedModel) {
                  // Ensure database is ready
                  if (!db) {
                    await initDB();
                  }
                  
                  if (selectedModel === 'default') {
                    // Clear database first
                    await clearDatabase();
                    
                    // Fetch and import default model directly (same as manual import)
                    try {
                      const response = await fetch('./default_model.json');
                      if (!response.ok) {
                        throw new Error('Failed to fetch default_model.json');
                      }
                      const importedData = await response.json();
                      
                      if (!Array.isArray(importedData)) {
                        console.error("Invalid file format.");
                        return;
                      }
                      
                      if (!db) {
                        console.error("Database not initialized");
                        return;
                      }
                      
                      const transaction = db.transaction([storeName], "readwrite");
                      const store = transaction.objectStore(storeName);
                      
                      let importedCount = 0;
                      let processed = 0;
                      const total = importedData.length;
                      
                      return new Promise((resolve) => {
                        if (total === 0) {
                          localStorage.setItem('modelProcessed', 'default');
                          console.log("‚úÖ Default model imported: 0 recordings (empty file)");
                          resolve();
                          return;
                        }
                        
                        importedData.forEach((recording) => {
                          const addRequest = store.add(recording);
                          addRequest.onsuccess = () => {
                            importedCount++;
                            processed++;
                            if (processed === total) {
                              localStorage.setItem('modelProcessed', 'default');
                              console.log(`‚úÖ Default model imported: ${importedCount} recordings loaded.`);
                              resolve();
                            }
                          };
                          addRequest.onerror = (e) => {
                            processed++;
                            console.warn("Error adding recording:", e);
                            if (processed === total) {
                              localStorage.setItem('modelProcessed', 'default');
                              console.log(`‚úÖ Default model import completed: ${importedCount} recordings loaded.`);
                              resolve();
                            }
                          };
                        });
                      });
                    } catch (error) {
                      console.error("Error fetching/importing default model:", error);
                      // Try alternative path
                      try {
                        const response = await fetch('../default_model.json');
                        const importedData = await response.json();
                        // Same import logic as above...
                        console.log("Trying alternative path...");
                      } catch (e) {
                        console.error("Failed to load default model from both paths:", e);
                      }
                    }
                  } else if (selectedModel === 'blank') {
                    // Clear database for blank model
                    await clearDatabase();
                    localStorage.setItem('modelProcessed', 'blank');
                    console.log("‚úÖ Database cleared for blank model");
                  }
                }
              } catch (error) {
                console.error("Error auto-importing default model:", error);
              }
            }
          } catch (error) {
            console.error("Initialization error:", error);
          }
        })();
      })();
    </script>
    
    <!-- Smartphone Mode Toggle Script -->
    <script>
      // Smartphone mode toggle functionality
      (function() {
        const smartphoneModeBtn = document.getElementById('smartphoneModeBtn');
        const body = document.body;
        
        if (!smartphoneModeBtn) return;
        
        // Check for saved preference
        const savedMode = localStorage.getItem('smartphoneMode');
        if (savedMode === 'true') {
          body.classList.add('smartphone-mode');
          smartphoneModeBtn.classList.add('active');
        }
        
        // Toggle smartphone mode
        smartphoneModeBtn.addEventListener('click', function() {
          body.classList.toggle('smartphone-mode');
          smartphoneModeBtn.classList.toggle('active');
          
          // Save preference
          const isActive = body.classList.contains('smartphone-mode');
          localStorage.setItem('smartphoneMode', isActive);
        });
      })();
    </script>
  </body>
</html>
